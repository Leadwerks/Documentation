
<table>
<tbody>
<tr>
<td><a href="#_enetaddress">_ENetAddress</a></td>
<td><a href="#_enetcallbacks">_ENetCallbacks</a></td>
</tr>
<tr>
<td><a href="#_enetcompressor">_ENetCompressor</a></td>
<td><a href="#_enetevent">_ENetEvent</a></td>
</tr>
<tr>
<td><a href="#_eneteventtype">_ENetEventType</a></td>
<td><a href="#_enethost">_ENetHost</a></td>
</tr>
<tr>
<td><a href="#_enetlistnode">_ENetListNode</a></td>
<td><a href="#_enetpacket">_ENetPacket</a></td>
</tr>
<tr>
<td><a href="#_enetpacketflag">_ENetPacketFlag</a></td>
<td><a href="#_enetpeer">_ENetPeer</a></td>
</tr>
<tr>
<td><a href="#_exception_disposition">_EXCEPTION_DISPOSITION</a></td>
<td><a href="#crowdagentstate">CrowdAgentState</a></td>
</tr>
<tr>
<td><a href="#dtallochint">dtAllocHint</a></td>
<td><a href="#dtbvnode">dtBVNode</a></td>
</tr>
<tr>
<td><a href="#dtcompressedtileflags">dtCompressedTileFlags</a></td>
<td><a href="#dtcrowd">dtCrowd</a></td>
</tr>
<tr>
<td><a href="#dtcrowdagent">dtCrowdAgent</a></td>
<td><a href="#dtcrowdagentparams">dtCrowdAgentParams</a></td>
</tr>
<tr>
<td><a href="#dtcrowdneighbour">dtCrowdNeighbour</a></td>
<td><a href="#dtlink">dtLink</a></td>
</tr>
<tr>
<td><a href="#dtmeshheader">dtMeshHeader</a></td>
<td><a href="#dtmeshtile">dtMeshTile</a></td>
</tr>
<tr>
<td><a href="#dtnavmesh">dtNavMesh</a></td>
<td><a href="#dtnavmeshcreateparams">dtNavMeshCreateParams</a></td>
</tr>
<tr>
<td><a href="#dtnavmeshparams">dtNavMeshParams</a></td>
<td><a href="#dtnavmeshquery">dtNavMeshQuery</a></td>
</tr>
<tr>
<td><a href="#dtnodeflags">dtNodeFlags</a></td>
<td><a href="#dtnodepool">dtNodePool</a></td>
</tr>
<tr>
<td><a href="#dtoffmeshconnection">dtOffMeshConnection</a></td>
<td><a href="#dtpathcorridor">dtPathCorridor</a></td>
</tr>
<tr>
<td><a href="#dtpoly">dtPoly</a></td>
<td><a href="#dtpolydetail">dtPolyDetail</a></td>
</tr>
<tr>
<td><a href="#dtpolytypes">dtPolyTypes</a></td>
<td><a href="#dtstraightpathflags">dtStraightPathFlags</a></td>
</tr>
<tr>
<td><a href="#dtstraightpathoptions">dtStraightPathOptions</a></td>
<td><a href="#dttileflags">dtTileFlags</a></td>
</tr>
<tr>
<td><a href="#dudebugdraw">duDebugDraw</a></td>
<td><a href="#rcallochint">rcAllocHint</a></td>
</tr>
<tr>
<td><a href="#rcbuildcontoursflags">rcBuildContoursFlags</a></td>
<td><a href="#rccompactcell">rcCompactCell</a></td>
</tr>
<tr>
<td><a href="#rccompactheightfield">rcCompactHeightfield</a></td>
<td><a href="#rccompactspan">rcCompactSpan</a></td>
</tr>
<tr>
<td><a href="#rcconfig">rcConfig</a></td>
<td><a href="#rccontext">rcContext</a></td>
</tr>
<tr>
<td><a href="#rccontour">rcContour</a></td>
<td><a href="#rccontourset">rcContourSet</a></td>
</tr>
<tr>
<td><a href="#rcheightfield">rcHeightfield</a></td>
<td><a href="#rcheightfieldlayer">rcHeightfieldLayer</a></td>
</tr>
<tr>
<td><a href="#rcheightfieldlayerset">rcHeightfieldLayerSet</a></td>
<td><a href="#rcintarray">rcIntArray</a></td>
</tr>
<tr>
<td><a href="#rclogcategory">rcLogCategory</a></td>
<td><a href="#rcpolymesh">rcPolyMesh</a></td>
</tr>
<tr>
<td><a href="#rcpolymeshdetail">rcPolyMeshDetail</a></td>
<td><a href="#rcspan">rcSpan</a></td>
</tr>
<tr>
<td><a href="#rcspanpool">rcSpanPool</a></td>
<td><a href="#rctimerlabel">rcTimerLabel</a></td>
</tr>
<tr>
<td><a href="#monostate">monostate</a></td>
<td><a href="#nullopt_t">nullopt_t</a></td>
</tr>
<tr>
<td><a href="#entity">Entity</a></td>
<td><a href="#terrain">Terrain</a></td>
</tr>
<tr>
<td><a href="#updateflags">UpdateFlags</a></td>
<td><a href="#vmaallocation_t">VmaAllocation_T</a></td>
</tr>
<tr>
<td><a href="#vmaallocationcreateflagbits">VmaAllocationCreateFlagBits</a></td>
<td><a href="#vmaallocationinfo">VmaAllocationInfo</a></td>
</tr>
<tr>
<td><a href="#vmaallocator_t">VmaAllocator_T</a></td>
<td><a href="#vmaallocatorcreateflagbits">VmaAllocatorCreateFlagBits</a></td>
</tr>
<tr>
<td><a href="#vmaallocatorcreateinfo">VmaAllocatorCreateInfo</a></td>
<td><a href="#vmadefragmentationcontext_t">VmaDefragmentationContext_T</a></td>
</tr>
<tr>
<td><a href="#vmadefragmentationflagbits">VmaDefragmentationFlagBits</a></td>
<td><a href="#vmadefragmentationinfo">VmaDefragmentationInfo</a></td>
</tr>
<tr>
<td><a href="#vmadefragmentationinfo2">VmaDefragmentationInfo2</a></td>
<td><a href="#vmadefragmentationstats">VmaDefragmentationStats</a></td>
</tr>
<tr>
<td><a href="#vmadevicememorycallbacks">VmaDeviceMemoryCallbacks</a></td>
<td><a href="#vmapool_t">VmaPool_T</a></td>
</tr>
<tr>
<td><a href="#vmapoolcreateflagbits">VmaPoolCreateFlagBits</a></td>
<td><a href="#vmapoolcreateinfo">VmaPoolCreateInfo</a></td>
</tr>
<tr>
<td><a href="#vmapoolstats">VmaPoolStats</a></td>
<td><a href="#vmarecordflagbits">VmaRecordFlagBits</a></td>
</tr>
<tr>
<td><a href="#vmarecordsettings">VmaRecordSettings</a></td>
<td><a href="#vmastatinfo">VmaStatInfo</a></td>
</tr>
<tr>
<td><a href="#vmastats">VmaStats</a></td>
<td><a href="#vmavulkanfunctions">VmaVulkanFunctions</a></td>
</tr>
<tr>
<td><a href="#compositor_cumulativestats">Compositor_CumulativeStats</a></td>
<td><a href="#compositor_frametiming">Compositor_FrameTiming</a></td>
</tr>
<tr>
<td><a href="#compositor_overlaysettings">Compositor_OverlaySettings</a></td>
<td><a href="#d3d12texturedata_t">D3D12TextureData_t</a></td>
</tr>
<tr>
<td><a href="#distortioncoordinates_t">DistortionCoordinates_t</a></td>
<td><a href="#driverdirectmode_frametiming">DriverDirectMode_FrameTiming</a></td>
</tr>
<tr>
<td><a href="#ecollisionboundsstyle">ECollisionBoundsStyle</a></td>
<td><a href="#edeviceactivitylevel">EDeviceActivityLevel</a></td>
</tr>
<tr>
<td><a href="#ehmdtrackingstyle">EHmdTrackingStyle</a></td>
<td><a href="#eoverlaydirection">EOverlayDirection</a></td>
</tr>
<tr>
<td><a href="#etrackedcontrollerrole">ETrackedControllerRole</a></td>
<td><a href="#etrackeddeviceclass">ETrackedDeviceClass</a></td>
</tr>
<tr>
<td><a href="#etrackeddeviceproperty">ETrackedDeviceProperty</a></td>
<td><a href="#etrackedpropertyerror">ETrackedPropertyError</a></td>
</tr>
<tr>
<td><a href="#etrackinguniverseorigin">ETrackingUniverseOrigin</a></td>
<td><a href="#evrapplicationerror">EVRApplicationError</a></td>
</tr>
<tr>
<td><a href="#evrapplicationproperty">EVRApplicationProperty</a></td>
<td><a href="#evrapplicationtransitionstate">EVRApplicationTransitionState</a></td>
</tr>
<tr>
<td><a href="#evrapplicationtype">EVRApplicationType</a></td>
<td><a href="#evrbuttonid">EVRButtonId</a></td>
</tr>
<tr>
<td><a href="#evrcompositorerror">EVRCompositorError</a></td>
<td><a href="#evrcompositortimingmode">EVRCompositorTimingMode</a></td>
</tr>
<tr>
<td><a href="#evrcontrolleraxistype">EVRControllerAxisType</a></td>
<td><a href="#evrcontrollereventoutputtype">EVRControllerEventOutputType</a></td>
</tr>
<tr>
<td><a href="#evreventtype">EVREventType</a></td>
<td><a href="#evrfirmwareerror">EVRFirmwareError</a></td>
</tr>
<tr>
<td><a href="#evriniterror">EVRInitError</a></td>
<td><a href="#evrmousebutton">EVRMouseButton</a></td>
</tr>
<tr>
<td><a href="#evrnotificationerror">EVRNotificationError</a></td>
<td><a href="#evrnotificationtype">EVRNotificationType</a></td>
</tr>
<tr>
<td><a href="#evroverlayerror">EVROverlayError</a></td>
<td><a href="#evrrendermodelerror">EVRRenderModelError</a></td>
</tr>
<tr>
<td><a href="#evrscreenshoterror">EVRScreenshotError</a></td>
<td><a href="#evrstate">EVRState</a></td>
</tr>
<tr>
<td><a href="#evrsubmitflags">EVRSubmitFlags</a></td>
<td><a href="#hiddenareamesh_t">HiddenAreaMesh_t</a></td>
</tr>
<tr>
<td><a href="#imu_offscaleflags">Imu_OffScaleFlags</a></td>
<td><a href="#ivrchaperone">IVRChaperone</a></td>
</tr>
<tr>
<td><a href="#ivrchaperonesetup">IVRChaperoneSetup</a></td>
<td><a href="#ivrcompositor">IVRCompositor</a></td>
</tr>
<tr>
<td><a href="#ivrextendeddisplay">IVRExtendedDisplay</a></td>
<td><a href="#ivrnotifications">IVRNotifications</a></td>
</tr>
<tr>
<td><a href="#ivrscreenshots">IVRScreenshots</a></td>
<td><a href="#rendermodel_componentstate_t">RenderModel_ComponentState_t</a></td>
</tr>
<tr>
<td><a href="#rendermodel_texturemap_t">RenderModel_TextureMap_t</a></td>
<td><a href="#rendermodel_vertex_t">RenderModel_Vertex_t</a></td>
</tr>
<tr>
<td><a href="#trackeddevicepose_t">TrackedDevicePose_t</a></td>
<td><a href="#vrbonetransform_t">VRBoneTransform_t</a></td>
</tr>
<tr>
<td><a href="#vrcontrolleraxis_t">VRControllerAxis_t</a></td>
<td><a href="#vrcontrollerstate001_t">VRControllerState001_t</a></td>
</tr>
<tr>
<td><a href="#vrevent_controller_t">VREvent_Controller_t</a></td>
<td><a href="#vrevent_keyboard_t">VREvent_Keyboard_t</a></td>
</tr>
<tr>
<td><a href="#vrevent_mouse_t">VREvent_Mouse_t</a></td>
<td><a href="#vrevent_notification_t">VREvent_Notification_t</a></td>
</tr>
<tr>
<td><a href="#vrevent_overlay_t">VREvent_Overlay_t</a></td>
<td><a href="#vrevent_process_t">VREvent_Process_t</a></td>
</tr>
<tr>
<td><a href="#vrevent_reserved_t">VREvent_Reserved_t</a></td>
<td><a href="#vrevent_scroll_t">VREvent_Scroll_t</a></td>
</tr>
<tr>
<td><a href="#vrevent_status_t">VREvent_Status_t</a></td>
<td><a href="#vrevent_t">VREvent_t</a></td>
</tr>
<tr>
<td><a href="#vrevent_touchpadmove_t">VREvent_TouchPadMove_t</a></td>
<td><a href="#vroverlayflags">VROverlayFlags</a></td>
</tr>
<tr>
<td><a href="#vroverlayinputmethod">VROverlayInputMethod</a></td>
<td><a href="#vroverlaytransformtype">VROverlayTransformType</a></td>
</tr>
<tr>
<td><a href="#vrskeletalsummarydata_t">VRSkeletalSummaryData_t</a></td>
<td><a href="#vrtexturebounds_t">VRTextureBounds_t</a></td>
</tr>
<tr>
<td><a href="#vrtexturewithpose_t">VRTextureWithPose_t</a></td>
<td><a href="#vrvulkantexturedata_t">VRVulkanTextureData_t</a></td>
</tr>
</tbody>
</table>


## _ENetAddress
Portable internet address structure. The host must be specified in network byte-order, and the port must be in host byte-order. The constant ENET_HOST_ANY may be used to specify the default server host. The constant ENET_HOST_BROADCAST may be used to specify the broadcast address (255.255.255.255). This makes sense for enet_host_connect, but not for enet_host_create. Once a server responds to a broadcast, the address is updated from ENET_HOST_BROADCAST to the server's actual IP address.

## _ENetCallbacks
@file callbacks.h @brief ENet callbacks

## _ENetCompressor
An ENet packet compressor for compressing UDP packets before socket sends or receives.
### _ENetCompressor.compress
Compresses from inBuffers[0:inBufferCount-1], containing inLimit bytes, to outData, outputting at most outLimit bytes. Should return 0 on failure.
### _ENetCompressor.context
Context data for the compressor. Must be non-NULL.
### _ENetCompressor.decompress
Decompresses from inData, containing inLimit bytes, to outData, outputting at most outLimit bytes. Should return 0 on failure.
### _ENetCompressor.destroy
Destroys the context when compression is disabled or the host is destroyed. May be NULL.

## _ENetEvent
* An ENet event as returned by enet_host_service(). @sa enet_host_service

## _ENetEventType
An ENet event type, as specified in @ref ENetEvent.

## _ENetHost
An ENet host for communicating with peers. * * No fields should be modified unless otherwise stated. @sa enet_host_create() @sa enet_host_destroy() @sa enet_host_connect() @sa enet_host_service() @sa enet_host_flush() @sa enet_host_broadcast() @sa enet_host_compress() @sa enet_host_compress_with_range_coder() @sa enet_host_channel_limit() @sa enet_host_bandwidth_limit() @sa enet_host_bandwidth_throttle()

## _ENetListNode
@file list.h @brief ENet list management

## _ENetPacket
* ENet packet structure. * * An ENet data packet that may be sent to or received from a peer. The shown * fields should only be read and never modified. The data field contains the * allocated data for the packet. The dataLength fields specifies the length * of the allocated data. The flags field is either 0 (specifying no flags), * or a bitwise-or of any combination of the following flags: * * ENET_PACKET_FLAG_RELIABLE - packet must be received by the target peer * and resend attempts should be made until the packet is delivered * * ENET_PACKET_FLAG_UNSEQUENCED - packet will not be sequenced with other packets * (not supported for reliable packets) * * ENET_PACKET_FLAG_NO_ALLOCATE - packet will not allocate data, and user must supply it instead @sa ENetPacketFlag

## _ENetPacketFlag
* Packet flag bit constants. * * The host must be specified in network byte-order, and the port must be in * host byte-order. The constant ENET_HOST_ANY may be used to specify the * default server host. @sa ENetPacket

## _ENetPeer
An ENet peer which data packets may be sent or received from. No fields should be modified unless otherwise specified.

## _EXCEPTION_DISPOSITION
@file enet.h @brief ENet public header file @file win32.h @brief ENet Win32 header
### ALboolean
8-bit boolean
### ALbyte
signed 8-bit 2's complement integer
### ALCboolean
8-bit boolean
### ALCbyte
signed 8-bit 2's complement integer
### ALCchar
character
### ALCdouble
64-bit IEEE754 floating-point
### ALCenum
enumerated 32-bit value
### ALCfloat
32-bit IEEE754 floating-point
### ALchar
character
### ALCint
signed 32-bit 2's complement integer
### ALCshort
signed 16-bit 2's complement integer
### ALCsizei
non-negative 32-bit binary integer size
### ALCubyte
unsigned 8-bit integer
### ALCuint
unsigned 32-bit integer
### ALCushort
unsigned 16-bit integer
### ALCvoid
void type (for opaque pointers only)
### ALdouble
64-bit IEEE754 floating-point
### alEnable(System.Int32)
Boolean True. Indicate Source has relative coordinates. Directional source, inner cone angle, in degrees. Range: [0-360] Default: 360 Directional source, outer cone angle, in degrees. Range: [0-360] Default: 360 Specify the pitch to be applied, either at source, or on mixer results, at listener. Range: [0.5-2.0] Default: 1.0 Specify the current location in three dimensional space. OpenAL, like OpenGL, uses a right handed coordinate system, where in a frontal default view X (thumb) points right, Y points up (index finger), and Z points towards the viewer/camera (middle finger). To switch from a left handed coordinate system, flip the sign on the Z coordinate. Listener position is always in the world coordinate system. Specify the current direction. Specify the current velocity in three dimensional space. Indicate whether source is looping. Type: ALboolean? Range: [AL_TRUE, AL_FALSE] Default: FALSE. Indicate the buffer to provide sound samples. Type: ALuint. Range: any valid Buffer id. Indicate the gain (volume amplification) applied. Type: ALfloat. Range: ]0.0- ] A value of 1.0 means un-attenuated/unchanged. Each division by 2 equals an attenuation of -6dB. Each multiplicaton with 2 equals an amplification of +6dB. A value of 0.0 is meaningless with respect to a logarithmic scale; it is interpreted as zero volume - the channel is effectively disabled. Indicate maximum source attenuation Type: ALfloat Range: [0.0 - 1.0] Logarthmic Indicate listener orientation. at/up Specify the channel mask. (Creative) Type: ALuint Range: [0 - 255] Source state information. Buffer Queue params Source buffer position information Sound samples: format specifier. source specific reference distance Type: ALfloat Range: 0.0 - +inf At 0.0, no distance attenuation occurs. Default is 1.0. source specific rolloff factor Type: ALfloat Range: 0.0 - +inf Directional source, outer cone gain. Default: 0.0 Range: [0.0 - 1.0] Logarithmic Indicate distance above which sources are not attenuated using the inverse clamped distance model. Default: +inf Type: ALfloat Range: 0.0 - +inf Sound samples: frequency, in units of Hertz [Hz]. This is the number of samples per second. Half of the sample frequency marks the maximum significant frequency component. Buffer state. Not supported for public use (yet). Errors: No Error. Invalid Name paramater passed to AL call. Invalid parameter passed to AL call. Invalid enum parameter value. Illegal call. No mojo. Context strings: Vendor Name. Global tweakage. Doppler scale. Default 1.0 Tweaks speed of propagation. Speed of Sound in units per second Distance models used in conjunction with DistanceModel implicit: NONE, which disances distance attenuation.
### ALenum
enumerated 32-bit value
### ALfloat
32-bit IEEE754 floating-point
### alGenBuffers(System.Int32,System.UInt32*)
BUFFER Buffer objects are storage space for sample data. Buffers are referred to by Sources. One Buffer can be used by multiple Sources. Properties include: - Frequency (Query only) AL_FREQUENCY ALint Size (Query only) AL_SIZE ALint Bits (Query only) AL_BITS ALint Channels (Query only) AL_CHANNELS ALint
### alGenSources(System.Int32,System.UInt32*)
SOURCE Sources represent individual sound objects in 3D-space. Sources take the PCM data provided in the specified Buffer, apply Source-specific modifications, and then submit them to be mixed according to spatial arrangement etc. Properties include: - Gain AL_GAIN ALfloat Min Gain AL_MIN_GAIN ALfloat Max Gain AL_MAX_GAIN ALfloat Position AL_POSITION ALfloat[3] Velocity AL_VELOCITY ALfloat[3] Direction AL_DIRECTION ALfloat[3] Head Relative Mode AL_SOURCE_RELATIVE ALint (AL_TRUE or AL_FALSE) Reference Distance AL_REFERENCE_DISTANCE ALfloat Max Distance AL_MAX_DISTANCE ALfloat RollOff Factor AL_ROLLOFF_FACTOR ALfloat Inner Angle AL_CONE_INNER_ANGLE ALint or ALfloat Outer Angle AL_CONE_OUTER_ANGLE ALint or ALfloat Cone Outer Gain AL_CONE_OUTER_GAIN ALint or ALfloat Pitch AL_PITCH ALfloat Looping AL_LOOPING ALint (AL_TRUE or AL_FALSE) MS Offset AL_MSEC_OFFSET ALint or ALfloat Byte Offset AL_BYTE_OFFSET ALint or ALfloat Sample Offset AL_SAMPLE_OFFSET ALint or ALfloat Attached Buffer AL_BUFFER ALint State (Query only) AL_SOURCE_STATE ALint Buffers Queued (Query only) AL_BUFFERS_QUEUED ALint Buffers Processed (Query only) AL_BUFFERS_PROCESSED ALint
### ALint
signed 32-bit 2's complement integer
### ALshort
signed 16-bit 2's complement integer
### ALsizei
non-negative 32-bit binary integer size
### ALubyte
unsigned 8-bit integer
### ALuint
unsigned 32-bit integer
### ALushort
unsigned 16-bit integer
### ALvoid
void type (for opaque pointers only)

## CrowdAgentState
The type of navigation mesh polygon the agent is currently traversing. @ingroup crowd
### DT_POLYTYPE_GROUND
The polygon is a standard convex polygon that is part of the surface of the mesh.
### DT_POLYTYPE_OFFMESH_CONNECTION
The polygon is an off-mesh connection consisting of two vertices.
### DT_TILE_FREE_DATA
The navigation mesh owns the tile memory and is responsible for freeing it.
### dtAlloc(System.Int32,dtAllocHint)
Allocates a memory block. @param[in] size The size, in bytes of memory, to allocate. @param[in] hint A hint to the allocator on how long the memory is expected to be in use. @return A pointer to the beginning of the allocated memory block, or null if the allocation failed. @see dtFree
### dtAllocCrowd
Allocates a crowd object using the Detour allocator. @return A crowd object that is ready for initialization, or null on failure. @ingroup crowd
### dtAllocFunc
A memory allocation function. @see dtAllocSetCustom

## dtAllocHint
Provides hint values to the memory allocator on how long the memory is expected to be used.
### dtAllocNavMesh
Allocates a navigation mesh object using the Detour allocator. @return A navigation mesh that is ready for initialization, or null on failure. @ingroup detour
### dtAllocNavMeshQuery
Allocates a query object using the Detour allocator. @return An allocated query object, or null on failure. @ingroup detour
### dtAllocSetCustom(=FUNC:System.Void*(System.Int32,dtAllocHint),=FUNC:System.Void(System.Void*))
Sets the base custom allocation functions to be used by Detour. @param[in] allocFunc The memory allocation function to be used by #dtAlloc @param[in] freeFunc The memory de-allocation function to be used by #dtFree

## dtBVNode
Bounding volume node. @note This structure is rarely if ever used by the end user. @see dtMeshTile
### dtCalcPolyCenter(System.Single*,System.UInt16!System.Runtime.CompilerServices.IsConst*,System.Int32,System.Single!System.Runtime.CompilerServices.IsConst*)
Derives the centroid of a convex polygon. @param[out] tc The centroid of the polgyon. [(x, y, z)] @param[in] idx The polygon indices. [(vertIndex) * @p nidx] @param[in] nidx The number of indices in the polygon. [Limit: >= 3] @param[in] verts The polygon vertices. [(x, y, z) * vertCount]
### dtClosestHeightPointTriangle(System.Single!System.Runtime.CompilerServices.IsConst*,System.Single!System.Runtime.CompilerServices.IsConst*,System.Single!System.Runtime.CompilerServices.IsConst*,System.Single!System.Runtime.CompilerServices.IsConst*,System.Single*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)
Derives the y-axis height of the closest point on the triangle from the specified reference point. @param[in] p The reference point from which to test. [(x, y, z)] @param[in] a Vertex A of triangle ABC. [(x, y, z)] @param[in] b Vertex B of triangle ABC. [(x, y, z)] @param[in] c Vertex C of triangle ABC. [(x, y, z)] @param[out] h The resulting height.
### dtClosestPtPointTriangle(System.Single*,System.Single!System.Runtime.CompilerServices.IsConst*,System.Single!System.Runtime.CompilerServices.IsConst*,System.Single!System.Runtime.CompilerServices.IsConst*,System.Single!System.Runtime.CompilerServices.IsConst*)
Derives the closest point on a triangle from the specified reference point. @param[out] closest The closest point on the triangle. @param[in] p The reference point from which to test. [(x, y, z)] @param[in] a Vertex A of triangle ABC. [(x, y, z)] @param[in] b Vertex B of triangle ABC. [(x, y, z)] @param[in] c Vertex C of triangle ABC. [(x, y, z)]

## dtCompressedTileFlags
Flags for addTile
### dtCreateNavMeshData(dtNavMeshCreateParams*,System.Byte**,System.Int32*)
Builds navigation mesh tile data from the provided tile creation data. @ingroup detour @param[in] params Tile creation data. @param[out] outData The resulting tile data. @param[out] outDataSize The size of the tile data array. @return True if the tile data was successfully created.

## dtCrowd
Provides local steering behaviors for a group of agents. @ingroup crowd
### dtCrowd.addAgent(System.Single!System.Runtime.CompilerServices.IsConst*,dtCrowdAgentParams!System.Runtime.CompilerServices.IsConst*)
Adds a new agent to the crowd. @param[in] pos The requested position of the agent. [(x, y, z)] @param[in] params The configutation of the agent. @return The index of the agent in the agent pool. Or -1 if the agent could not be added.
### dtCrowd.getActiveAgents(dtCrowdAgent**,System.Int32!System.Runtime.CompilerServices.IsConst)
Gets the active agents int the agent pool. @param[out] agents An array of agent pointers. [(#dtCrowdAgent *) * maxAgents] @param[in] maxAgents The size of the crowd agent array. @return The number of agents returned in @p agents.
### dtCrowd.getAgentCount
The maximum number of agents that can be managed by the object. @return The maximum number of agents.
### dtCrowd.getEditableFilter
Gets the filter used by the crowd. @return The filter used by the crowd.
### dtCrowd.getFilter
Gets the filter used by the crowd. @return The filter used by the crowd.
### dtCrowd.getGrid
Gets the crowd's proximity grid. @return The crowd's proximity grid.
### dtCrowd.getNavMeshQuery
Gets the query object used by the crowd.
### dtCrowd.getPathQueue
Gets the crowd's path request queue. @return The crowd's path request queue.
### dtCrowd.getQueryExtents
Gets the search extents [(x, y, z)] used by the crowd for query operations. @return The search extents used by the crowd. [(x, y, z)]
### dtCrowd.getVelocitySampleCount
Gets the velocity sample count. @return The velocity sample count.
### dtCrowd.init(System.Int32!System.Runtime.CompilerServices.IsConst,System.Single!System.Runtime.CompilerServices.IsConst,dtNavMesh*)
Initializes the crowd. @param[in] maxAgents The maximum number of agents the crowd can manage. [Limit: >= 1] @param[in] maxAgentRadius The maximum radius of any agent that will be added to the crowd. [Limit: > 0] @param[in] nav The navigation mesh to use for planning. @return True if the initialization succeeded.
### dtCrowd.update(System.Single!System.Runtime.CompilerServices.IsConst,dtCrowdAgentDebugInfo*)
Updates the steering and positions of all agents. @param[in] dt The time, in seconds, to update the simulation. [Limit: > 0] @param[out] debug A debug object to load with debug information. [Opt]

## dtCrowdAgent
Represents an agent managed by a #dtCrowd object. @ingroup crowd
### dtCrowdAgent.active
1 if the agent is active, or 0 if the agent is in an unused slot in the agent pool.
### dtCrowdAgent.boundary
The local boundary data for the agent.
### dtCrowdAgent.cornerFlags
The local path corridor corner flags. (See: #dtStraightPathFlags) [(flags) * #ncorners]
### dtCrowdAgent.cornerPolys
The reference id of the polygon being entered at the corner. [(polyRef) * #ncorners]
### dtCrowdAgent.cornerVerts
The local path corridor corners for the agent. (Staight path.) [(x, y, z) * #ncorners]
### dtCrowdAgent.corridor
The path corridor the agent is using.
### dtCrowdAgent.desiredSpeed
The desired speed.
### dtCrowdAgent.ncorners
The number of corners.
### dtCrowdAgent.neis
The known neighbors of the agent.
### dtCrowdAgent.nneis
The number of neighbors.
### dtCrowdAgent.params
The agent's configuration parameters.
### dtCrowdAgent.state
The type of mesh polygon the agent is traversing. (See: #CrowdAgentState)
### dtCrowdAgent.topologyOptTime
Time since the agent's path corridor was optimized.

## dtCrowdAgentParams
Configuration parameters for a crowd agent. @ingroup crowd
### dtCrowdAgentParams.collisionQueryRange
Defines how close a collision element must be before it is considered for steering behaviors. [Limits: > 0]
### dtCrowdAgentParams.separationWeight
How aggresive the agent manager should be at avoiding collisions with this agent. [Limit: >= 0]
### dtCrowdAgentParams.updateFlags
Flags that impact steering behavior. (See: #UpdateFlags)
### dtCrowdAgentParams.userData
User defined data attached to the agent.

## dtCrowdNeighbour
Provides neighbor data for agents managed by the crowd. @ingroup crowd @see dtCrowdAgent::neis, dtCrowd
### dtFree(System.Void*)
Deallocates a memory block. @param[in] ptr A pointer to a memory block previously allocated using #dtAlloc. @see dtAlloc
### dtFreeCrowd(dtCrowd*)
Frees the specified crowd object using the Detour allocator. @param[in] ptr A crowd object allocated using #dtAllocCrowd @ingroup crowd
### dtFreeFunc
A memory deallocation function. @param[in] ptr A pointer to a memory block previously allocated using #dtAllocFunc. @see dtAllocSetCustom
### dtFreeNavMesh(dtNavMesh*)
Frees the specified navigation mesh object using the Detour allocator. @param[in] navmesh A navigation mesh allocated using #dtAllocNavMesh @ingroup detour
### dtFreeNavMeshQuery(dtNavMeshQuery*)
Frees the specified query object using the Detour allocator. @param[in] query A query object allocated using #dtAllocNavMeshQuery @ingroup detour

## dtLink
Defines a link between polygons. @note This structure is rarely if ever used by the end user. @see dtMeshTile

## dtMeshHeader
Provides high level information related to a dtMeshTile object. @ingroup detour
### dtMeshHeader.bvQuantFactor
The bounding volume quantization factor.
### dtMeshHeader.detailVertCount
The number of unique vertices in the detail mesh. (In addition to the polygon vertices.)

## dtMeshTile
Defines a navigation mesh tile. @ingroup detour
### dtMeshTile.bvTree
The tile bounding volume nodes. [Size: dtMeshHeader::bvNodeCount] (Will be null if bounding volumes are disabled.)
### dtMeshTile.detailTris
The detail mesh's triangles. [(vertA, vertB, vertC) * dtMeshHeader::detailTriCount]
### dtMeshTile.detailVerts
The detail mesh's unique vertices. [(x, y, z) * dtMeshHeader::detailVertCount]

## dtNavMesh
A navigation mesh based on tiles of convex polygons. @ingroup detour
### dtNavMesh.addTile(System.Byte*,System.Int32,System.Int32,System.UInt32,System.UInt32*)
Adds a tile to the navigation mesh. @param[in] data Data for the new tile mesh. (See: #dtCreateNavMeshData) @param[in] dataSize Data size of the new tile mesh. @param[in] flags Tile flags. (See: #dtTileFlags) @param[in] lastRef The desired reference for the tile. (When reloading a tile.) [opt] [Default: 0] @param[out] result The tile reference. (If the tile was succesfully added.) [opt] @return The status flags for the operation.
### dtNavMesh.baseOffMeshLinks(dtMeshTile*)
Builds internal polygons links for a tile.
### dtNavMesh.calcTileLoc(System.Single!System.Runtime.CompilerServices.IsConst*,System.Int32*,System.Int32*)
@} @{ @name Query Functions Calculates the tile grid location for the specified world position. @param[in] pos The world position for the query. [(x, y, z)] @param[out] tx The tile's x-location. (x, y) @param[out] ty The tile's y-location. (x, y)
### dtNavMesh.closestPointOnPolyInTile(dtMeshTile!System.Runtime.CompilerServices.IsConst*,System.UInt32,System.Single!System.Runtime.CompilerServices.IsConst*,System.Single*)
Returns closest point on polygon.
### dtNavMesh.connectExtLinks(dtMeshTile*,dtMeshTile*,System.Int32)
Builds external polygon links for a tile.
### dtNavMesh.connectExtOffMeshLinks(dtMeshTile*,dtMeshTile*,System.Int32)
Builds external polygon links for a tile.
### dtNavMesh.connectIntLinks(dtMeshTile*)
Builds internal polygons links for a tile.
### dtNavMesh.decodePolyId(System.UInt32,System.UInt32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)
Decodes a standard polygon reference. @note This function is generally meant for internal use only. @param[in] ref The polygon reference to decode. @param[out] salt The tile's salt value. @param[out] it The index of the tile. @param[out] ip The index of the polygon within the tile. @see #encodePolyId
### dtNavMesh.decodePolyIdPoly(System.UInt32)
Extracts the polygon's index (within its tile) from the specified polygon reference. @note This function is generally meant for internal use only. @param[in] ref The polygon reference. @see #encodePolyId
### dtNavMesh.decodePolyIdSalt(System.UInt32)
Extracts a tile's salt value from the specified polygon reference. @note This function is generally meant for internal use only. @param[in] ref The polygon reference. @see #encodePolyId
### dtNavMesh.decodePolyIdTile(System.UInt32)
Extracts the tile's index from the specified polygon reference. @note This function is generally meant for internal use only. @param[in] ref The polygon reference. @see #encodePolyId
### dtNavMesh.encodePolyId(System.UInt32,System.UInt32,System.UInt32)
@} @{ @name Encoding and Decoding These functions are generally meant for internal use only. Derives a standard polygon reference. @note This function is generally meant for internal use only. @param[in] salt The tile's salt value. @param[in] it The index of the tile. @param[in] ip The index of the polygon within the tile.
### dtNavMesh.findConnectingPolys(System.Single!System.Runtime.CompilerServices.IsConst*,System.Single!System.Runtime.CompilerServices.IsConst*,dtMeshTile!System.Runtime.CompilerServices.IsConst*,System.Int32,System.UInt32*,System.Single*,System.Int32)
Returns all polygons in neighbour tile based on portal defined by the segment.
### dtNavMesh.findNearestPolyInTile(dtMeshTile!System.Runtime.CompilerServices.IsConst*,System.Single!System.Runtime.CompilerServices.IsConst*,System.Single!System.Runtime.CompilerServices.IsConst*,System.Single*)
Find nearest polygon within a tile.
### dtNavMesh.getMaxTiles
The maximum number of tiles supported by the navigation mesh. @return The maximum number of tiles supported by the navigation mesh.
### dtNavMesh.getNeighbourTilesAt(System.Int32!System.Runtime.CompilerServices.IsConst,System.Int32!System.Runtime.CompilerServices.IsConst,System.Int32!System.Runtime.CompilerServices.IsConst,dtMeshTile**,System.Int32!System.Runtime.CompilerServices.IsConst)
Returns neighbour tile based on side.
### dtNavMesh.getOffMeshConnectionByRef(System.UInt32)
Gets the specified off-mesh connection. @param[in] ref The polygon reference of the off-mesh connection. @return The specified off-mesh connection, or null if the polygon reference is not valid.
### dtNavMesh.getOffMeshConnectionPolyEndPoints(System.UInt32,System.UInt32,System.Single*,System.Single*)
Gets the endpoints for an off-mesh connection, ordered by "direction of travel". @param[in] prevRef The reference of the polygon before the connection. @param[in] polyRef The reference of the off-mesh connection polygon. @param[out] startPos The start position of the off-mesh connection. [(x, y, z)] @param[out] endPos The end position of the off-mesh connection. [(x, y, z)] @return The status flags for the operation.
### dtNavMesh.getParams
The navigation mesh initialization params.
### dtNavMesh.getPolyArea(System.UInt32,System.Byte*)
Gets the user defined area for the specified polygon. @param[in] ref The polygon reference. @param[out] resultArea The area id for the polygon. @return The status flags for the operation.
### dtNavMesh.getPolyFlags(System.UInt32,System.UInt16*)
Gets the user defined flags for the specified polygon. @param[in] ref The polygon reference. @param[out] resultFlags The polygon flags. @return The status flags for the operation.
### dtNavMesh.getPolyRefBase(dtMeshTile!System.Runtime.CompilerServices.IsConst*)
Gets the polygon reference for the tile's base polygon. @param[in] tile The tile. @return The polygon reference for the base polygon in the specified tile.
### dtNavMesh.getTile(System.Int32)
@} Returns pointer to tile in the tile array.
### dtNavMesh.getTileAndPolyByRef(System.UInt32!System.Runtime.CompilerServices.IsConst,dtMeshTile!System.Runtime.CompilerServices.IsConst**,dtPoly!System.Runtime.CompilerServices.IsConst**)
Gets the tile and polygon for the specified polygon reference. @param[in] ref The reference for the a polygon. @param[out] tile The tile containing the polygon. @param[out] poly The polygon. @return The status flags for the operation.
### dtNavMesh.getTileAndPolyByRefUnsafe(System.UInt32!System.Runtime.CompilerServices.IsConst,dtMeshTile!System.Runtime.CompilerServices.IsConst**,dtPoly!System.Runtime.CompilerServices.IsConst**)
Returns the tile and polygon for the specified polygon reference. @param[in] ref A known valid reference for a polygon. @param[out] tile The tile containing the polygon. @param[out] poly The polygon.
### dtNavMesh.getTileAt(System.Int32!System.Runtime.CompilerServices.IsConst,System.Int32!System.Runtime.CompilerServices.IsConst,System.Int32!System.Runtime.CompilerServices.IsConst)
Gets the tile at the specified grid location. @param[in] x The tile's x-location. (x, y, layer) @param[in] y The tile's y-location. (x, y, layer) @param[in] layer The tile's layer. (x, y, layer) @return The tile, or null if the tile does not exist.
### dtNavMesh.getTileByRef(System.UInt32)
Gets the tile for the specified tile reference. @param[in] ref The tile reference of the tile to retrieve. @return The tile for the specified reference, or null if the reference is invalid.
### dtNavMesh.getTileRef(dtMeshTile!System.Runtime.CompilerServices.IsConst*)
Gets the tile reference for the specified tile. @param[in] tile The tile. @return The tile reference of the tile.
### dtNavMesh.getTileRefAt(System.Int32,System.Int32,System.Int32)
Gets the tile reference for the tile at specified grid location. @param[in] x The tile's x-location. (x, y, layer) @param[in] y The tile's y-location. (x, y, layer) @param[in] layer The tile's layer. (x, y, layer) @return The tile reference of the tile, or 0 if there is none.
### dtNavMesh.getTilesAt(System.Int32!System.Runtime.CompilerServices.IsConst,System.Int32!System.Runtime.CompilerServices.IsConst,dtMeshTile!System.Runtime.CompilerServices.IsConst**,System.Int32!System.Runtime.CompilerServices.IsConst)
Gets all tiles at the specified grid location. (All layers.) @param[in] x The tile's x-location. (x, y) @param[in] y The tile's y-location. (x, y) @param[out] tiles A pointer to an array of tiles that will hold the result. @param[in] maxTiles The maximum tiles the tiles parameter can hold. @return The number of tiles returned in the tiles array.
### dtNavMesh.getTilesAt(System.Int32!System.Runtime.CompilerServices.IsConst,System.Int32!System.Runtime.CompilerServices.IsConst,dtMeshTile**,System.Int32!System.Runtime.CompilerServices.IsConst)
Returns neighbour tile based on side.
### dtNavMesh.getTileStateSize(dtMeshTile!System.Runtime.CompilerServices.IsConst*)
Gets the size of the buffer required by #storeTileState to store the specified tile's state. @param[in] tile The tile. @return The size of the buffer required to store the state.
### dtNavMesh.init(dtNavMeshParams!System.Runtime.CompilerServices.IsConst*)
@{ @name Initialization and Tile Management Initializes the navigation mesh for tiled use. @param[in] params Initialization parameters. @return The status flags for the operation.
### dtNavMesh.init(System.Byte*,System.Int32!System.Runtime.CompilerServices.IsConst,System.Int32!System.Runtime.CompilerServices.IsConst)
Initializes the navigation mesh for single tile use. @param[in] data Data of the new tile. (See: #dtCreateNavMeshData) @param[in] dataSize The data size of the new tile. @param[in] flags The tile flags. (See: #dtTileFlags) @return The status flags for the operation. @see dtCreateNavMeshData
### dtNavMesh.isValidPolyRef(System.UInt32)
Checks the validity of a polygon reference. @param[in] ref The polygon reference to check. @return True if polygon reference is valid for the navigation mesh.
### dtNavMesh.queryPolygonsInTile(dtMeshTile!System.Runtime.CompilerServices.IsConst*,System.Single!System.Runtime.CompilerServices.IsConst*,System.Single!System.Runtime.CompilerServices.IsConst*,System.UInt32*,System.Int32!System.Runtime.CompilerServices.IsConst)
Queries polygons within a tile.
### dtNavMesh.removeTile(System.UInt32,System.Byte**,System.Int32*)
Removes the specified tile from the navigation mesh. @param[in] ref The reference of the tile to remove. @param[out] data Data associated with deleted tile. @param[out] dataSize Size of the data associated with deleted tile. @return The status flags for the operation.
### dtNavMesh.restoreTileState(dtMeshTile*,System.Byte!System.Runtime.CompilerServices.IsConst*,System.Int32!System.Runtime.CompilerServices.IsConst)
Restores the state of the tile. @param[in] tile The tile. @param[in] data The new state. (Obtained from #storeTileState.) @param[in] maxDataSize The size of the state within the data buffer. @return The status flags for the operation.
### dtNavMesh.setPolyFlags(System.UInt32,System.UInt16)
@} @{ @name State Management These functions do not effect #dtTileRef or #dtPolyRef's. Sets the user defined flags for the specified polygon. @param[in] ref The polygon reference. @param[in] flags The new flags for the polygon. @return The status flags for the operation.
### dtNavMesh.storeTileState(dtMeshTile!System.Runtime.CompilerServices.IsConst*,System.Byte*,System.Int32!System.Runtime.CompilerServices.IsConst)
Stores the non-structural state of the tile in the specified buffer. (Flags, area ids, etc.) @param[in] tile The tile. @param[out] data The buffer to store the tile's state in. @param[in] maxDataSize The size of the data buffer. [Limit: >= #getTileStateSize] @return The status flags for the operation.
### dtNavMesh.unconnectExtLinks(dtMeshTile*,dtMeshTile*)
Removes external links at specified side.

## dtNavMeshCreateParams
@} @fn float dtTriArea2D(const float* a, const float* b, const float* c) @par The vertices are projected onto the xz-plane, so the y-values are ignored. This is a low cost function than can be used for various purposes. Its main purpose is for point/line relationship testing. In all cases: A value of zero indicates that all vertices are collinear or represent the same point. (On the xz-plane.) When used for point/line relationship tests, AB usually represents a line against which the C point is to be tested. In this case: A positive value indicates that point C is to the left of line AB, looking from A toward B. A negative value indicates that point C is to the right of lineAB, looking from A toward B. When used for evaluating a triangle: The absolute value of the return value is two times the area of the triangle when it is projected onto the xz-plane. A positive return value indicates:  A negative return value indicates:  Represents the source data used to build an navigation mesh tile. @ingroup detour
### dtNavMeshCreateParams.buildBvTree
True if a bounding volume tree should be built for the tile. @note The BVTree is not normally needed for layered navigation meshes.
### dtNavMeshCreateParams.detailMeshes
@} @name Height Detail Attributes (Optional) See #rcPolyMeshDetail for details related to these attributes. @{
### dtNavMeshCreateParams.offMeshConAreas
User defined area ids assigned to the off-mesh connections. [Size: #offMeshConCount]
### dtNavMeshCreateParams.offMeshConCount
The number of off-mesh connections. [Limit: >= 0]
### dtNavMeshCreateParams.offMeshConDir
The permitted travel direction of the off-mesh connections. [Size: #offMeshConCount] 0 = Travel only from endpoint A to endpoint B. #DT_OFFMESH_CON_BIDIR = Bidirectional travel.
### dtNavMeshCreateParams.offMeshConFlags
User defined flags assigned to the off-mesh connections. [Size: #offMeshConCount]
### dtNavMeshCreateParams.offMeshConRad
Off-mesh connection radii. [Size: #offMeshConCount] [Unit: wu]
### dtNavMeshCreateParams.offMeshConUserID
The user defined ids of the off-mesh connection. [Size: #offMeshConCount]
### dtNavMeshCreateParams.offMeshConVerts
@} @name Off-Mesh Connections Attributes (Optional) Used to define a custom point-to-point edge within the navigation graph, an off-mesh connection is a user defined traversable connection made up to two vertices, at least one of which resides within a navigation mesh polygon. @{ Off-mesh connection vertices. [(ax, ay, az, bx, by, bz) * #offMeshConCount] [Unit: wu]
### dtNavMeshCreateParams.userId
@} @name Tile Attributes @note The tile grid/layer data can be left at zero if the destination is a single tile mesh. @{
### dtNavMeshCreateParams.verts
@name Polygon Mesh Attributes Used to create the base navigation graph. See #rcPolyMesh for details related to these attributes. @{
### dtNavMeshCreateParams.walkableHeight
@} @name General Configuration Attributes @{
### dtNavMeshDataSwapEndian(System.Byte*,System.Int32!System.Runtime.CompilerServices.IsConst)
Swaps endianess of the tile data. @param[in,out] data The tile data array. @param[in] dataSize The size of the data array.
### dtNavMeshHeaderSwapEndian(System.Byte*,System.Int32!System.Runtime.CompilerServices.IsConst)
Swaps the endianess of the tile data's header (#dtMeshHeader). @param[in,out] data The tile data array. @param[in] dataSize The size of the data array.

## dtNavMeshParams
Configuration parameters used to define multi-tile navigation meshes. The values are used to allocate space during the initialization of a navigation mesh. @see dtNavMesh::init() @ingroup detour

## dtNavMeshQuery
Provides the ability to perform pathfinding related queries against a navigation mesh. @ingroup detour
### dtNavMeshQuery.closestPointOnPoly(System.UInt32,System.Single!System.Runtime.CompilerServices.IsConst*,System.Single*)
Finds the closest point on the specified polygon. @param[in] ref The reference id of the polygon. @param[in] pos The position to check. [(x, y, z)] @param[out] closest The closest point on the polygon. [(x, y, z)] @returns The status flags for the query.
### dtNavMeshQuery.closestPointOnPolyBoundary(System.UInt32,System.Single!System.Runtime.CompilerServices.IsConst*,System.Single*)
Returns a point on the boundary closest to the source point if the source point is outside the polygon's xz-bounds. @param[in] ref The reference id to the polygon. @param[in] pos The position to check. [(x, y, z)] @param[out] closest The closest point. [(x, y, z)] @returns The status flags for the query.
### dtNavMeshQuery.closestPointOnPolyInTile(dtMeshTile!System.Runtime.CompilerServices.IsConst*,dtPoly!System.Runtime.CompilerServices.IsConst*,System.Single!System.Runtime.CompilerServices.IsConst*,System.Single*)
Returns closest point on polygon.
### dtNavMeshQuery.finalizeSlicedFindPath(System.UInt32*,System.Int32*,System.Int32!System.Runtime.CompilerServices.IsConst)
Finalizes and returns the results of a sliced path query. @param[out] path An ordered list of polygon references representing the path. (Start to end.) [(polyRef) * @p pathCount] @param[out] pathCount The number of polygons returned in the @p path array. @param[in] maxPath The max number of polygons the path array can hold. [Limit: >= 1] @returns The status flags for the query.
### dtNavMeshQuery.finalizeSlicedFindPathPartial(System.UInt32!System.Runtime.CompilerServices.IsConst*,System.Int32!System.Runtime.CompilerServices.IsConst,System.UInt32*,System.Int32*,System.Int32!System.Runtime.CompilerServices.IsConst)
Finalizes and returns the results of an incomplete sliced path query, returning the path to the furthest polygon on the existing path that was visited during the search. @param[out] existing An array of polygon references for the existing path. @param[out] existingSize The number of polygon in the @p existing array. @param[out] path An ordered list of polygon references representing the path. (Start to end.) [(polyRef) * @p pathCount] @param[out] pathCount The number of polygons returned in the @p path array. @param[in] maxPath The max number of polygons the @p path array can hold. [Limit: >= 1] @returns The status flags for the query.
### dtNavMeshQuery.findDistanceToWall(System.UInt32,System.Single!System.Runtime.CompilerServices.IsConst*,System.Single!System.Runtime.CompilerServices.IsConst,dtQueryFilter!System.Runtime.CompilerServices.IsConst*,System.Single*,System.Single*,System.Single*)
Finds the distance from the specified position to the nearest polygon wall. @param[in] startRef The reference id of the polygon containing @p centerPos. @param[in] centerPos The center of the search circle. [(x, y, z)] @param[in] maxRadius The radius of the search circle. @param[in] filter The polygon filter to apply to the query. @param[out] hitDist The distance to the nearest wall from @p centerPos. @param[out] hitPos The nearest position on the wall that was hit. [(x, y, z)] @param[out] hitNormal The normalized ray formed from the wall point to the source point. [(x, y, z)] @returns The status flags for the query.
### dtNavMeshQuery.findLocalNeighbourhood(System.UInt32,System.Single!System.Runtime.CompilerServices.IsConst*,System.Single!System.Runtime.CompilerServices.IsConst,dtQueryFilter!System.Runtime.CompilerServices.IsConst*,System.UInt32*,System.UInt32*,System.Int32*,System.Int32!System.Runtime.CompilerServices.IsConst)
Finds the non-overlapping navigation polygons in the local neighbourhood around the center position. @param[in] startRef The reference id of the polygon where the search starts. @param[in] centerPos The center of the query circle. [(x, y, z)] @param[in] radius The radius of the query circle. @param[in] filter The polygon filter to apply to the query. @param[out] resultRef The reference ids of the polygons touched by the circle. @param[out] resultParent The reference ids of the parent polygons for each result. Zero if a result polygon has no parent. [opt] @param[out] resultCount The number of polygons found. @param[in] maxResult The maximum number of polygons the result arrays can hold. @returns The status flags for the query.
### dtNavMeshQuery.findNearestPoly(System.Single!System.Runtime.CompilerServices.IsConst*,System.Single!System.Runtime.CompilerServices.IsConst*,dtQueryFilter!System.Runtime.CompilerServices.IsConst*,System.UInt32*,System.Single*)
@} @name Local Query Functions @{ Finds the polygon nearest to the specified center point. @param[in] center The center of the search box. [(x, y, z)] @param[in] extents The search distance along each axis. [(x, y, z)] @param[in] filter The polygon filter to apply to the query. @param[out] nearestRef The reference id of the nearest polygon. @param[out] nearestPt The nearest point on the polygon. [opt] [(x, y, z)] @returns The status flags for the query.
### dtNavMeshQuery.findNearestPolyInTile(dtMeshTile!System.Runtime.CompilerServices.IsConst*,System.Single!System.Runtime.CompilerServices.IsConst*,System.Single!System.Runtime.CompilerServices.IsConst*,dtQueryFilter!System.Runtime.CompilerServices.IsConst*,System.Single*)
Find nearest polygon within a tile.
### dtNavMeshQuery.findPath(System.UInt32,System.UInt32,System.Single!System.Runtime.CompilerServices.IsConst*,System.Single!System.Runtime.CompilerServices.IsConst*,dtQueryFilter!System.Runtime.CompilerServices.IsConst*,System.UInt32*,System.Int32*,System.Int32!System.Runtime.CompilerServices.IsConst)
@name Standard Pathfinding Functions Finds a path from the start polygon to the end polygon. @param[in] startRef The refrence id of the start polygon. @param[in] endRef The reference id of the end polygon. @param[in] startPos A position within the start polygon. [(x, y, z)] @param[in] endPos A position within the end polygon. [(x, y, z)] @param[in] filter The polygon filter to apply to the query. @param[out] path An ordered list of polygon references representing the path. (Start to end.) [(polyRef) * @p pathCount] @param[out] pathCount The number of polygons returned in the @p path array. @param[in] maxPath The maximum number of polygons the @p path array can hold. [Limit: >= 1]
### dtNavMeshQuery.findPolysAroundCircle(System.UInt32,System.Single!System.Runtime.CompilerServices.IsConst*,System.Single!System.Runtime.CompilerServices.IsConst,dtQueryFilter!System.Runtime.CompilerServices.IsConst*,System.UInt32*,System.UInt32*,System.Single*,System.Int32*,System.Int32!System.Runtime.CompilerServices.IsConst)
@} @name Dijkstra Search Functions @{ Finds the polygons along the navigation graph that touch the specified circle. @param[in] startRef The reference id of the polygon where the search starts. @param[in] centerPos The center of the search circle. [(x, y, z)] @param[in] radius The radius of the search circle. @param[in] filter The polygon filter to apply to the query. @param[out] resultRef The reference ids of the polygons touched by the circle. [opt] @param[out] resultParent The reference ids of the parent polygons for each result. Zero if a result polygon has no parent. [opt] @param[out] resultCost The search cost from @p centerPos to the polygon. [opt] @param[out] resultCount The number of polygons found. [opt] @param[in] maxResult The maximum number of polygons the result arrays can hold. @returns The status flags for the query.
### dtNavMeshQuery.findPolysAroundShape(System.UInt32,System.Single!System.Runtime.CompilerServices.IsConst*,System.Int32!System.Runtime.CompilerServices.IsConst,dtQueryFilter!System.Runtime.CompilerServices.IsConst*,System.UInt32*,System.UInt32*,System.Single*,System.Int32*,System.Int32!System.Runtime.CompilerServices.IsConst)
Finds the polygons along the naviation graph that touch the specified convex polygon. @param[in] startRef The reference id of the polygon where the search starts. @param[in] verts The vertices describing the convex polygon. (CCW) [(x, y, z) * @p nverts] @param[in] nverts The number of vertices in the polygon. @param[in] filter The polygon filter to apply to the query. @param[out] resultRef The reference ids of the polygons touched by the search polygon. [opt] @param[out] resultParent The reference ids of the parent polygons for each result. Zero if a result polygon has no parent. [opt] @param[out] resultCost The search cost from the centroid point to the polygon. [opt] @param[out] resultCount The number of polygons found. @param[in] maxResult The maximum number of polygons the result arrays can hold. @returns The status flags for the query.
### dtNavMeshQuery.findRandomPoint(dtQueryFilter!System.Runtime.CompilerServices.IsConst*,=FUNC:System.Single,System.UInt32*,System.Single*)
Returns random location on navmesh. Polygons are chosen weighted by area. The search runs in linear related to number of polygon. @param[in] filter The polygon filter to apply to the query. @param[in] frand Function returning a random number [0..1). @param[out] randomRef The reference id of the random location. @param[out] randomPt The random location. @returns The status flags for the query.
### dtNavMeshQuery.findRandomPointAroundCircle(System.UInt32,System.Single!System.Runtime.CompilerServices.IsConst*,System.Single!System.Runtime.CompilerServices.IsConst,dtQueryFilter!System.Runtime.CompilerServices.IsConst*,=FUNC:System.Single,System.UInt32*,System.Single*)
Returns random location on navmesh within the reach of specified location. Polygons are chosen weighted by area. The search runs in linear related to number of polygon. The location is not exactly constrained by the circle, but it limits the visited polygons. @param[in] startRef The reference id of the polygon where the search starts. @param[in] centerPos The center of the search circle. [(x, y, z)] @param[in] filter The polygon filter to apply to the query. @param[in] frand Function returning a random number [0..1). @param[out] randomRef The reference id of the random location. @param[out] randomPt The random location. [(x, y, z)] @returns The status flags for the query.
### dtNavMeshQuery.findStraightPath(System.Single!System.Runtime.CompilerServices.IsConst*,System.Single!System.Runtime.CompilerServices.IsConst*,System.UInt32!System.Runtime.CompilerServices.IsConst*,System.Int32!System.Runtime.CompilerServices.IsConst,System.Single*,System.Byte*,System.UInt32*,System.Int32*,System.Int32!System.Runtime.CompilerServices.IsConst,System.Int32!System.Runtime.CompilerServices.IsConst)
Finds the straight path from the start to the end position within the polygon corridor. @param[in] startPos Path start position. [(x, y, z)] @param[in] endPos Path end position. [(x, y, z)] @param[in] path An array of polygon references that represent the path corridor. @param[in] pathSize The number of polygons in the @p path array. @param[out] straightPath Points describing the straight path. [(x, y, z) * @p straightPathCount]. @param[out] straightPathFlags Flags describing each point. (See: #dtStraightPathFlags) [opt] @param[out] straightPathRefs The reference id of the polygon that is being entered at each point. [opt] @param[out] straightPathCount The number of points in the straight path. @param[in] maxStraightPath The maximum number of points the straight path arrays can hold. [Limit: > 0] @param[in] options Query options. (see: #dtStraightPathOptions) @returns The status flags for the query.
### dtNavMeshQuery.getAttachedNavMesh
Gets the navigation mesh the query object is using. @return The navigation mesh the query object is using.
### dtNavMeshQuery.getEdgeMidPoint(System.UInt32,System.UInt32,System.Single*)
Returns edge mid point between two polygons.
### dtNavMeshQuery.getNeighbourTileAt(System.Int32,System.Int32,System.Int32)
@} Returns neighbour tile based on side.
### dtNavMeshQuery.getPolyHeight(System.UInt32,System.Single!System.Runtime.CompilerServices.IsConst*,System.Single*)
Gets the height of the polygon at the provided position using the height detail. (Most accurate.) @param[in] ref The reference id of the polygon. @param[in] pos A position within the xz-bounds of the polygon. [(x, y, z)] @param[out] height The height at the surface of the polygon. @returns The status flags for the query.
### dtNavMeshQuery.getPolyWallSegments(System.UInt32,dtQueryFilter!System.Runtime.CompilerServices.IsConst*,System.Single*,System.UInt32*,System.Int32*,System.Int32!System.Runtime.CompilerServices.IsConst)
Returns the segments for the specified polygon, optionally including portals. @param[in] ref The reference id of the polygon. @param[in] filter The polygon filter to apply to the query. @param[out] segmentVerts The segments. [(ax, ay, az, bx, by, bz) * segmentCount] @param[out] segmentRefs The reference ids of each segment's neighbor polygon. Or zero if the segment is a wall. [opt] [(parentRef) * @p segmentCount] @param[out] segmentCount The number of segments returned. @param[in] maxSegments The maximum number of segments the result arrays can hold. @returns The status flags for the query.
### dtNavMeshQuery.getPortalPoints(System.UInt32,System.UInt32,System.Single*,System.Single*,System.Byte*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Byte*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)
Returns portal points between two polygons.
### dtNavMeshQuery.initSlicedFindPath(System.UInt32,System.UInt32,System.Single!System.Runtime.CompilerServices.IsConst*,System.Single!System.Runtime.CompilerServices.IsConst*,dtQueryFilter!System.Runtime.CompilerServices.IsConst*)
@} @name Sliced Pathfinding Functions Common use case: -# Call initSlicedFindPath() to initialize the sliced path query. -# Call updateSlicedFindPath() until it returns complete. -# Call finalizeSlicedFindPath() to get the path. @{ Intializes a sliced path query. @param[in] startRef The refrence id of the start polygon. @param[in] endRef The reference id of the end polygon. @param[in] startPos A position within the start polygon. [(x, y, z)] @param[in] endPos A position within the end polygon. [(x, y, z)] @param[in] filter The polygon filter to apply to the query. @returns The status flags for the query.
### dtNavMeshQuery.isInClosedList(System.UInt32)
Returns true if the polygon reference is in the closed list. @param[in] ref The reference id of the polygon to check. @returns True if the polygon is in closed list.
### dtNavMeshQuery.isValidPolyRef(System.UInt32,dtQueryFilter!System.Runtime.CompilerServices.IsConst*)
@} @name Miscellaneous Functions @{ Returns true if the polygon reference is valid and passes the filter restrictions. @param[in] ref The polygon reference to check. @param[in] filter The filter to apply.
### dtNavMeshQuery.moveAlongSurface(System.UInt32,System.Single!System.Runtime.CompilerServices.IsConst*,System.Single!System.Runtime.CompilerServices.IsConst*,dtQueryFilter!System.Runtime.CompilerServices.IsConst*,System.Single*,System.UInt32*,System.Int32*,System.Int32!System.Runtime.CompilerServices.IsConst)
Moves from the start to the end position constrained to the navigation mesh. @param[in] startRef The reference id of the start polygon. @param[in] startPos A position of the mover within the start polygon. [(x, y, x)] @param[in] endPos The desired end position of the mover. [(x, y, z)] @param[in] filter The polygon filter to apply to the query. @param[out] resultPos The result position of the mover. [(x, y, z)] @param[out] visited The reference ids of the polygons visited during the move. @param[out] visitedCount The number of polygons visited during the move. @param[in] maxVisitedSize The maximum number of polygons the @p visited array can hold. @returns The status flags for the query.
### dtNavMeshQuery.queryPolygons(System.Single!System.Runtime.CompilerServices.IsConst*,System.Single!System.Runtime.CompilerServices.IsConst*,dtQueryFilter!System.Runtime.CompilerServices.IsConst*,System.UInt32*,System.Int32*,System.Int32!System.Runtime.CompilerServices.IsConst)
Finds polygons that overlap the search box. @param[in] center The center of the search box. [(x, y, z)] @param[in] extents The search distance along each axis. [(x, y, z)] @param[in] filter The polygon filter to apply to the query. @param[out] polys The reference ids of the polygons that overlap the query box. @param[out] polyCount The number of polygons in the search result. @param[in] maxPolys The maximum number of polygons the search result can hold. @returns The status flags for the query.
### dtNavMeshQuery.queryPolygonsInTile(dtMeshTile!System.Runtime.CompilerServices.IsConst*,System.Single!System.Runtime.CompilerServices.IsConst*,System.Single!System.Runtime.CompilerServices.IsConst*,dtQueryFilter!System.Runtime.CompilerServices.IsConst*,System.UInt32*,System.Int32!System.Runtime.CompilerServices.IsConst)
Queries polygons within a tile.
### dtNavMeshQuery.raycast(System.UInt32,System.Single!System.Runtime.CompilerServices.IsConst*,System.Single!System.Runtime.CompilerServices.IsConst*,dtQueryFilter!System.Runtime.CompilerServices.IsConst*,System.Single*,System.Single*,System.UInt32*,System.Int32*,System.Int32!System.Runtime.CompilerServices.IsConst)
Casts a 'walkability' ray along the surface of the navigation mesh from the start position toward the end position. @param[in] startRef The reference id of the start polygon. @param[in] startPos A position within the start polygon representing the start of the ray. [(x, y, z)] @param[in] endPos The position to cast the ray toward. [(x, y, z)] @param[out] t The hit parameter. (FLT_MAX if no wall hit.) @param[out] hitNormal The normal of the nearest wall hit. [(x, y, z)] @param[in] filter The polygon filter to apply to the query. @param[out] path The reference ids of the visited polygons. [opt] @param[out] pathCount The number of visited polygons. [opt] @param[in] maxPath The maximum number of polygons the @p path array can hold. @returns The status flags for the query.
### dtNavMeshQuery.updateSlicedFindPath(System.Int32!System.Runtime.CompilerServices.IsConst,System.Int32*)
Updates an in-progress sliced path query. @param[in] maxIter The maximum number of iterations to perform. @param[out] doneIters The actual number of iterations completed. [opt] @returns The status flags for the query.
### dtNextPow2(System.UInt32)
@} @name Miscellanious functions. @{

## dtNodeFlags
@struct dtNavMeshCreateParams @par This structure is used to marshal data between the Recast mesh generation pipeline and Detour navigation components. See the rcPolyMesh and rcPolyMeshDetail documentation for detailed information related to mesh structure. Units are usually in voxels (vx) or world units (wu). The units for voxels, grid size, and cell size are all based on the values of #cs and #ch. The standard navigation mesh build process is to create tile data using dtCreateNavMeshData, then add the tile to a navigation mesh using either the dtNavMesh single tile  function or the dtNavMesh::addTile() function. @see dtCreateNavMeshData

## dtNodePool
Gets the node pool. @returns The node pool.
### dtObstacleRef
@defgroup crowd Crowd Members in this module implement local steering and dynamic avoidance features. The crowd is the big beast of the navigation features. It not only handles a lot of the path management for you, but also local steering and dynamic avoidance between members of the crowd. I.e. It can keep your agents from running into each other. Main class: #dtCrowd The #dtNavMeshQuery and #dtPathCorridor classes provide perfectly good, easy to use path planning features. But in the end they only give you points that your navigation client should be moving toward. When it comes to deciding things like agent velocity and steering to avoid other agents, that is up to you to implement. Unless, of course, you decide to use #dtCrowd. Basically, you add an agent to the crowd, providing various configuration settings such as maximum speed and acceleration. You also provide a local target to more toward. The crowd manager then provides, with every update, the new agent position and velocity for the frame. The movement will be constrained to the navigation mesh, and steering will be applied to ensure agents managed by the crowd do not collide with each other. This is very powerful feature set. But it comes with limitations. The biggest limitation is that you must give control of the agent's position completely over to the crowd manager. You can update things like maximum speed and acceleration. But in order for the crowd manager to do its thing, it can't allow you to constantly be giving it overrides to position and velocity. So you give up direct control of the agent's movement. It belongs to the crowd. The second biggest limitation revolves around the fact that the crowd manager deals with local planning. So the agent's target should never be more than 256 polygons aways from its current position. If it is, you risk your agent failing to reach its target. So you may still need to do long distance planning and provide the crowd manager with intermediate targets. Other significant limitations: - All agents using the crowd manager will use the same #dtQueryFilter. - Crowd management is relatively expensive. The maximum agents under crowd management at any one time is between 20 and 30. A good place to start is a maximum of 25 agents for 0.5ms per frame. @note This is a summary list of members. Use the index or search feature to find minor members. @struct dtCrowdAgentParams @see dtCrowdAgent, dtCrowd::addAgent(), dtCrowd::updateAgentParameters() @var dtCrowdAgentParams::obstacleAvoidanceType @par #dtCrowd permits agents to use different avoidance configurations. This value is the index of the #dtObstacleAvoidanceParams within the crowd. @see dtObstacleAvoidanceParams, dtCrowd::setObstacleAvoidanceParams(), dtCrowd::getObstacleAvoidanceParams() @var dtCrowdAgentParams::collisionQueryRange @par Collision elements include other agents and navigation mesh boundaries. This value is often based on the agent radius and/or maximum speed. E.g. radius * 8 @var dtCrowdAgentParams::pathOptimizationRange @par Only applicalbe if #updateFlags includes the #DT_CROWD_OPTIMIZE_VIS flag. This value is often based on the agent radius. E.g. radius * 30 @see dtPathCorridor::optimizePathVisibility() @var dtCrowdAgentParams::separationWeight @par A higher value will result in agents trying to stay farther away from each other at the cost of more difficult steering in tight spaces.

## dtOffMeshConnection
Defines an navigation mesh off-mesh connection within a dtMeshTile object. An off-mesh connection is a user defined traversable connection made up to two vertices.
### dtOffMeshConnection.flags
Link flags. @note These are not the connection's user defined flags. Those are assigned via the connection's dtPoly definition. These are link flags used for internal purposes.
### dtOffMeshConnection.poly
The polygon reference of the connection within the tile.
### dtOffMeshConnection.pos
The endpoints of the connection. [(ax, ay, az, bx, by, bz)]
### dtOffMeshConnection.rad
The radius of the endpoints. [Limit: >= 0]
### dtOffMeshConnection.side
End point side.
### dtOffMeshConnection.userId
The id of the offmesh connection. (User assigned when the navigation mesh is built.)
### dtOverlapBounds(System.Single!System.Runtime.CompilerServices.IsConst*,System.Single!System.Runtime.CompilerServices.IsConst*,System.Single!System.Runtime.CompilerServices.IsConst*,System.Single!System.Runtime.CompilerServices.IsConst*)
Determines if two axis-aligned bounding boxes overlap. @param[in] amin Minimum bounds of box A. [(x, y, z)] @param[in] amax Maximum bounds of box A. [(x, y, z)] @param[in] bmin Minimum bounds of box B. [(x, y, z)] @param[in] bmax Maximum bounds of box B. [(x, y, z)] @return True if the two AABB's overlap. @see dtOverlapQuantBounds
### dtOverlapPolyPoly2D(System.Single!System.Runtime.CompilerServices.IsConst*,System.Int32!System.Runtime.CompilerServices.IsConst,System.Single!System.Runtime.CompilerServices.IsConst*,System.Int32!System.Runtime.CompilerServices.IsConst)
Determines if the two convex polygons overlap on the xz-plane. @param[in] polya Polygon A vertices. [(x, y, z) * @p npolya] @param[in] npolya The number of vertices in polygon A. @param[in] polyb Polygon B vertices. [(x, y, z) * @p npolyb] @param[in] npolyb The number of vertices in polygon B. @return True if the two polygons overlap.
### dtOverlapQuantBounds(System.UInt16!System.Runtime.CompilerServices.IsConst*,System.UInt16!System.Runtime.CompilerServices.IsConst*,System.UInt16!System.Runtime.CompilerServices.IsConst*,System.UInt16!System.Runtime.CompilerServices.IsConst*)
Determines if two axis-aligned bounding boxes overlap. @param[in] amin Minimum bounds of box A. [(x, y, z)] @param[in] amax Maximum bounds of box A. [(x, y, z)] @param[in] bmin Minimum bounds of box B. [(x, y, z)] @param[in] bmax Maximum bounds of box B. [(x, y, z)] @return True if the two AABB's overlap. @see dtOverlapBounds

## dtPathCorridor
Represents a dynamic polygon corridor used to plan agent movement. @ingroup crowd, detour
### dtPathCorridor.getFirstPoly
The polygon reference id of the first polygon in the corridor, the polygon containing the position. @return The polygon reference id of the first polygon in the corridor. (Or zero if there is no path.)
### dtPathCorridor.getLastPoly
The polygon reference id of the last polygon in the corridor, the polygon containing the target. @return The polygon reference id of the last polygon in the corridor. (Or zero if there is no path.)
### dtPathCorridor.getPath
The corridor's path. @return The corridor's path. [(polyRef) * #getPathCount()]
### dtPathCorridor.getPathCount
The number of polygons in the current corridor path. @return The number of polygons in the current corridor path.
### dtPathCorridor.getPos
Gets the current position within the corridor. (In the first polygon.) @return The current position within the corridor.
### dtPathCorridor.getTarget
Gets the current target within the corridor. (In the last polygon.) @return The current target within the corridor.
### dtPathCorridor.init(System.Int32!System.Runtime.CompilerServices.IsConst)
Allocates the corridor's path buffer. @param[in] maxPath The maximum path size the corridor can handle. @return True if the initialization succeeded.
### dtPathCorridor.isValid(System.Int32!System.Runtime.CompilerServices.IsConst,dtNavMeshQuery*,dtQueryFilter!System.Runtime.CompilerServices.IsConst*)
Checks the current corridor path to see if its polygon references remain valid. @param[in] maxLookAhead The number of polygons from the beginning of the corridor to search. @param[in] navquery The query object used to build the corridor. @param[in] filter The filter to apply to the operation.
### dtPathCorridor.movePosition(System.Single!System.Runtime.CompilerServices.IsConst*,dtNavMeshQuery*,dtQueryFilter!System.Runtime.CompilerServices.IsConst*)
Moves the position from the current location to the desired location, adjusting the corridor as needed to reflect the change. @param[in] npos The desired new position. [(x, y, z)] @param[in] navquery The query object used to build the corridor. @param[in] filter The filter to apply to the operation.
### dtPathCorridor.moveTargetPosition(System.Single!System.Runtime.CompilerServices.IsConst*,dtNavMeshQuery*,dtQueryFilter!System.Runtime.CompilerServices.IsConst*)
Moves the target from the curent location to the desired location, adjusting the corridor as needed to reflect the change. @param[in] npos The desired new target position. [(x, y, z)] @param[in] navquery The query object used to build the corridor. @param[in] filter The filter to apply to the operation.
### dtPathCorridor.optimizePathTopology(dtNavMeshQuery*,dtQueryFilter!System.Runtime.CompilerServices.IsConst*)
Attempts to optimize the path using a local area search. (Partial replanning.) @param[in] navquery The query object used to build the corridor. @param[in] filter The filter to apply to the operation.
### dtPathCorridor.optimizePathVisibility(System.Single!System.Runtime.CompilerServices.IsConst*,System.Single!System.Runtime.CompilerServices.IsConst,dtNavMeshQuery*,dtQueryFilter!System.Runtime.CompilerServices.IsConst*)
Attempts to optimize the path if the specified point is visible from the current position. @param[in] next The point to search toward. [(x, y, z]) @param[in] pathOptimizationRange The maximum range to search. [Limit: > 0] @param[in] navquery The query object used to build the corridor. @param[in] filter The filter to apply to the operation.
### dtPathCorridor.reset(System.UInt32,System.Single!System.Runtime.CompilerServices.IsConst*)
Resets the path corridor to the specified position. @param[in] ref The polygon reference containing the position. @param[in] pos The new position in the corridor. [(x, y, z)]
### dtPathCorridor.setCorridor(System.Single!System.Runtime.CompilerServices.IsConst*,System.UInt32!System.Runtime.CompilerServices.IsConst*,System.Int32!System.Runtime.CompilerServices.IsConst)
Loads a new path and target into the corridor. @param[in] target The target location within the last polygon of the path. [(x, y, z)] @param[in] path The path corridor. [(polyRef) * @p npolys] @param[in] npath The number of polygons in the path.
### dtPathQueue.PathQuery.path
Result.
### dtPathQueue.PathQuery.startPos
Path find start and end location.
### dtPathQueue.PathQuery.status
State.
### dtPointInPolygon(System.Single!System.Runtime.CompilerServices.IsConst*,System.Single!System.Runtime.CompilerServices.IsConst*,System.Int32!System.Runtime.CompilerServices.IsConst)
Determines if the specified point is inside the convex polygon on the xz-plane. @param[in] pt The point to check. [(x, y, z)] @param[in] verts The polygon vertices. [(x, y, z) * @p nverts] @param[in] nverts The number of vertices. [Limit: >= 3] @return True if the point is inside the polygon.

## dtPoly
Defines a polyogn within a dtMeshTile object. @ingroup detour
### dtPoly.areaAndtype
The bit packed area id and polygon type. @note Use the structure's set and get methods to acess this value.
### dtPoly.firstLink
Index to first link in linked list. (Or #DT_NULL_LINK if there is no link.)
### dtPoly.flags
The user defined polygon flags.
### dtPoly.getArea
Gets the user defined area id.
### dtPoly.getType
Gets the polygon type. (See: #dtPolyTypes)
### dtPoly.neis
Packed data representing neighbor polygons references and flags for each edge.
### dtPoly.setType(System.Byte)
Sets the polygon type. (See: #dtPolyTypes.)
### dtPoly.vertCount
The number of vertices in the polygon.
### dtPoly.verts
The indices of the polygon's vertices. The actual vertices are located in dtMeshTile::verts.

## dtPolyDetail
Defines the location of detail sub-mesh data within a dtMeshTile.
### dtPolyRef
A handle to a polygon within a navigation mesh tile. @ingroup detour

## dtPolyTypes
Flags representing the type of a navigation mesh polygon.
### dtQueryFilter.getAreaCost(System.Int32!System.Runtime.CompilerServices.IsConst)
@name Getters and setters for the default implementation data. @{ Returns the traversal cost of the area. @param[in] i The id of the area. @returns The traversal cost of the area.
### dtQueryFilter.getCost(System.Single!System.Runtime.CompilerServices.IsConst*,System.Single!System.Runtime.CompilerServices.IsConst*,System.UInt32!System.Runtime.CompilerServices.IsConst,dtMeshTile!System.Runtime.CompilerServices.IsConst*,dtPoly!System.Runtime.CompilerServices.IsConst*,System.UInt32!System.Runtime.CompilerServices.IsConst,dtMeshTile!System.Runtime.CompilerServices.IsConst*,dtPoly!System.Runtime.CompilerServices.IsConst*,System.UInt32!System.Runtime.CompilerServices.IsConst,dtMeshTile!System.Runtime.CompilerServices.IsConst*,dtPoly!System.Runtime.CompilerServices.IsConst*)
Returns cost to move from the beginning to the end of a line segment that is fully contained within a polygon. @param[in] pa The start position on the edge of the previous and current polygon. [(x, y, z)] @param[in] pb The end position on the edge of the current and next polygon. [(x, y, z)] @param[in] prevRef The reference id of the previous polygon. [opt] @param[in] prevTile The tile containing the previous polygon. [opt] @param[in] prevPoly The previous polygon. [opt] @param[in] curRef The reference id of the current polygon. @param[in] curTile The tile containing the current polygon. @param[in] curPoly The current polygon. @param[in] nextRef The refernece id of the next polygon. [opt] @param[in] nextTile The tile containing the next polygon. [opt] @param[in] nextPoly The next polygon. [opt]
### dtQueryFilter.getExcludeFlags
Returns the exclude flags for the filter. Any polygons that include one ore more of these flags will be excluded from the operation.
### dtQueryFilter.getIncludeFlags
Returns the include flags for the filter. Any polygons that include one or more of these flags will be included in the operation.
### dtQueryFilter.passFilter(System.UInt32!System.Runtime.CompilerServices.IsConst,dtMeshTile!System.Runtime.CompilerServices.IsConst*,dtPoly!System.Runtime.CompilerServices.IsConst*)
Returns true if the polygon can be visited. (I.e. Is traversable.) @param[in] ref The reference id of the polygon test. @param[in] tile The tile containing the polygon. @param[in] poly The polygon to test.
### dtQueryFilter.setAreaCost(System.Int32!System.Runtime.CompilerServices.IsConst,System.Single!System.Runtime.CompilerServices.IsConst)
Sets the traversal cost of the area. @param[in] i The id of the area. @param[in] cost The new cost of traversing the area.
### dtQueryFilter.setExcludeFlags(System.UInt16!System.Runtime.CompilerServices.IsConst)
Sets the exclude flags for the filter. @param[in] flags The new flags.
### dtQueryFilter.setIncludeFlags(System.UInt16!System.Runtime.CompilerServices.IsConst)
Sets the include flags for the filter. @param[in] flags The new flags.
### dtSqrt(System.Single)
Returns the square root of the value. @param[in] x The value. @return The square root of the vlaue.

## dtStraightPathFlags
Vertex flags returned by dtNavMeshQuery::findStraightPath.

## dtStraightPathOptions
Options for dtNavMeshQuery::findStraightPath.
### dtTileCache.decodeObstacleIdObstacle(System.UInt32)
Decodes an obstacle id.
### dtTileCache.decodeObstacleIdSalt(System.UInt32)
Decodes an obstacle salt.
### dtTileCache.decodeTileIdSalt(System.UInt32)
Decodes a tile salt.
### dtTileCache.decodeTileIdTile(System.UInt32)
Decodes a tile id.
### dtTileCache.encodeObstacleId(System.UInt32,System.UInt32)
Encodes an obstacle id.
### dtTileCache.encodeTileId(System.UInt32,System.UInt32)
Encodes a tile id.
### dtTileCacheHeaderSwapEndian(System.Byte*,System.Int32!System.Runtime.CompilerServices.IsConst)
Swaps the endianess of the compressed tile data's header (#dtTileCacheLayerHeader). Tile layer data does not need endian swapping as it consits only of bytes. @param[in,out] data The tile data array. @param[in] dataSize The size of the data array.

## dtTileFlags
Tile flags used for various functions and fields. For an example, see dtNavMesh::addTile().
### dtTileRef
A handle to a tile within a navigation mesh. @ingroup detour
### dtTriArea2D(System.Single!System.Runtime.CompilerServices.IsConst*,System.Single!System.Runtime.CompilerServices.IsConst*,System.Single!System.Runtime.CompilerServices.IsConst*)
@} @name Computational geometry helper functions. @{ Derives the signed xz-plane area of the triangle ABC, or the relationship of line AB to point C. @param[in] a Vertex A. [(x, y, z)] @param[in] b Vertex B. [(x, y, z)] @param[in] c Vertex C. [(x, y, z)] @return The signed xz-plane area of the triangle.
### dtVadd(System.Single*,System.Single!System.Runtime.CompilerServices.IsConst*,System.Single!System.Runtime.CompilerServices.IsConst*)
Performs a vector addition. (@p v1 + @p v2) @param[out] dest The result vector. [(x, y, z)] @param[in] v1 The base vector. [(x, y, z)] @param[in] v2 The vector to add to @p v1. [(x, y, z)]
### dtVcopy(System.Single*,System.Single!System.Runtime.CompilerServices.IsConst*)
Performs a vector copy. @param[out] dest The result. [(x, y, z)] @param[in] a The vector to copy. [(x, y, z)]
### dtVcross(System.Single*,System.Single!System.Runtime.CompilerServices.IsConst*,System.Single!System.Runtime.CompilerServices.IsConst*)
@} @name Vector helper functions. @{ Derives the cross product of two vectors. (@p v1 x @p v2) @param[out] dest The cross product. [(x, y, z)] @param[in] v1 A Vector [(x, y, z)] @param[in] v2 A vector [(x, y, z)]
### dtVdist(System.Single!System.Runtime.CompilerServices.IsConst*,System.Single!System.Runtime.CompilerServices.IsConst*)
Returns the distance between two points. @param[in] v1 A point. [(x, y, z)] @param[in] v2 A point. [(x, y, z)] @return The distance between the two points.
### dtVdist2D(System.Single!System.Runtime.CompilerServices.IsConst*,System.Single!System.Runtime.CompilerServices.IsConst*)
Derives the distance between the specified points on the xz-plane. @param[in] v1 A point. [(x, y, z)] @param[in] v2 A point. [(x, y, z)] @return The distance between the point on the xz-plane. The vectors are projected onto the xz-plane, so the y-values are ignored.
### dtVdist2DSqr(System.Single!System.Runtime.CompilerServices.IsConst*,System.Single!System.Runtime.CompilerServices.IsConst*)
Derives the square of the distance between the specified points on the xz-plane. @param[in] v1 A point. [(x, y, z)] @param[in] v2 A point. [(x, y, z)] @return The square of the distance between the point on the xz-plane.
### dtVdistSqr(System.Single!System.Runtime.CompilerServices.IsConst*,System.Single!System.Runtime.CompilerServices.IsConst*)
Returns the square of the distance between two points. @param[in] v1 A point. [(x, y, z)] @param[in] v2 A point. [(x, y, z)] @return The square of the distance between the two points.
### dtVdot(System.Single!System.Runtime.CompilerServices.IsConst*,System.Single!System.Runtime.CompilerServices.IsConst*)
Derives the dot product of two vectors. (@p v1 . @p v2) @param[in] v1 A Vector [(x, y, z)] @param[in] v2 A vector [(x, y, z)] @return The dot product.
### dtVdot2D(System.Single!System.Runtime.CompilerServices.IsConst*,System.Single!System.Runtime.CompilerServices.IsConst*)
Derives the dot product of two vectors on the xz-plane. (@p u . @p v) @param[in] u A vector [(x, y, z)] @param[in] v A vector [(x, y, z)] @return The dot product on the xz-plane. The vectors are projected onto the xz-plane, so the y-values are ignored.
### dtVequal(System.Single!System.Runtime.CompilerServices.IsConst*,System.Single!System.Runtime.CompilerServices.IsConst*)
Performs a 'sloppy' colocation check of the specified points. @param[in] p0 A point. [(x, y, z)] @param[in] p1 A point. [(x, y, z)] @return True if the points are considered to be at the same location. Basically, this function will return true if the specified points are close enough to eachother to be considered colocated.
### dtVlen(System.Single!System.Runtime.CompilerServices.IsConst*)
Derives the scalar length of the vector. @param[in] v The vector. [(x, y, z)] @return The scalar length of the vector.
### dtVlenSqr(System.Single!System.Runtime.CompilerServices.IsConst*)
Derives the square of the scalar length of the vector. (len * len) @param[in] v The vector. [(x, y, z)] @return The square of the scalar length of the vector.
### dtVmad(System.Single*,System.Single!System.Runtime.CompilerServices.IsConst*,System.Single!System.Runtime.CompilerServices.IsConst*,System.Single!System.Runtime.CompilerServices.IsConst)
Performs a scaled vector addition. (@p v1 + (@p v2 * @p s)) @param[out] dest The result vector. [(x, y, z)] @param[in] v1 The base vector. [(x, y, z)] @param[in] v2 The vector to scale and add to @p v1. [(x, y, z)] @param[in] s The amount to scale @p v2 by before adding to @p v1.
### dtVmax(System.Single*,System.Single!System.Runtime.CompilerServices.IsConst*)
Selects the maximum value of each element from the specified vectors. @param[in,out] mx A vector. (Will be updated with the result.) [(x, y, z)] @param[in] v A vector. [(x, y, z)]
### dtVmin(System.Single*,System.Single!System.Runtime.CompilerServices.IsConst*)
Selects the minimum value of each element from the specified vectors. @param[in,out] mn A vector. (Will be updated with the result.) [(x, y, z)] @param[in] v A vector. [(x, y, z)]
### dtVnormalize(System.Single*)
Normalizes the vector. @param[in,out] v The vector to normalize. [(x, y, z)]
### dtVperp2D(System.Single!System.Runtime.CompilerServices.IsConst*,System.Single!System.Runtime.CompilerServices.IsConst*)
Derives the xz-plane 2D perp product of the two vectors. (uz*vx - ux*vz) @param[in] u The LHV vector [(x, y, z)] @param[in] v The RHV vector [(x, y, z)] @return The dot product on the xz-plane. The vectors are projected onto the xz-plane, so the y-values are ignored.
### dtVscale(System.Single*,System.Single!System.Runtime.CompilerServices.IsConst*,System.Single!System.Runtime.CompilerServices.IsConst)
Scales the vector by the specified value. (@p v * @p t) @param[out] dest The result vector. [(x, y, z)] @param[in] v The vector to scale. [(x, y, z)] @param[in] t The scaling factor.
### dtVset(System.Single*,System.Single!System.Runtime.CompilerServices.IsConst,System.Single!System.Runtime.CompilerServices.IsConst,System.Single!System.Runtime.CompilerServices.IsConst)
Sets the vector elements to the specified values. @param[out] dest The result vector. [(x, y, z)] @param[in] x The x-value of the vector. @param[in] y The y-value of the vector. @param[in] z The z-value of the vector.
### dtVsub(System.Single*,System.Single!System.Runtime.CompilerServices.IsConst*,System.Single!System.Runtime.CompilerServices.IsConst*)
Performs a vector subtraction. (@p v1 - @p v2) @param[out] dest The result vector. [(x, y, z)] @param[in] v1 The base vector. [(x, y, z)] @param[in] v2 The vector to subtract from @p v1. [(x, y, z)]

## duDebugDraw
Abstract debug draw interface.
### duDebugDraw.begin(duDebugDrawPrimitives,System.Single)
Begin drawing primitives. @param prim [in] primitive type to draw, one of rcDebugDrawPrimitives. @param size [in] size of a primitive, applies to point size and line width only.
### duDebugDraw.end
End drawing primitives.
### duDebugDraw.vertex(System.Single!System.Runtime.CompilerServices.IsConst,System.Single!System.Runtime.CompilerServices.IsConst,System.Single!System.Runtime.CompilerServices.IsConst,System.UInt32,System.Single!System.Runtime.CompilerServices.IsConst,System.Single!System.Runtime.CompilerServices.IsConst)
Submit a vertex @param x,y,z [in] position of the verts. @param color [in] color of the verts.
### duDebugDraw.vertex(System.Single!System.Runtime.CompilerServices.IsConst,System.Single!System.Runtime.CompilerServices.IsConst,System.Single!System.Runtime.CompilerServices.IsConst,System.UInt32)
Submit a vertex @param x,y,z [in] position of the verts. @param color [in] color of the verts.
### duDebugDraw.vertex(System.Single!System.Runtime.CompilerServices.IsConst*,System.UInt32,System.Single!System.Runtime.CompilerServices.IsConst*)
Submit a vertex @param pos [in] position of the verts. @param color [in] color of the verts.
### duDebugDraw.vertex(System.Single!System.Runtime.CompilerServices.IsConst*,System.UInt32)
Submit a vertex @param pos [in] position of the verts. @param color [in] color of the verts.
### enet_deinitialize
Shuts down ENet globally. Should be called when a program that has initialized ENet exits.
### ENET_EVENT_TYPE_CONNECT
a connection request initiated by enet_host_connect has completed. * The peer field contains the peer which successfully connected.
### ENET_EVENT_TYPE_DISCONNECT
a peer has disconnected. This event is generated on a successful * completion of a disconnect initiated by enet_pper_disconnect, if * a peer has timed out, or if a connection request intialized by * enet_host_connect has timed out. The peer field contains the peer * which disconnected. The data field contains user supplied data * describing the disconnection, or 0, if none is available.
### ENET_EVENT_TYPE_NONE
no event occurred within the specified time limit
### ENET_EVENT_TYPE_RECEIVE
a packet has been received from a peer. The peer field specifies the * peer which sent the packet. The channelID field specifies the channel * number upon which the packet was received. The packet field contains * the packet that was received; this packet must be destroyed with * enet_packet_destroy after use.
### enet_malloc(System.UInt64)
@defgroup callbacks ENet internal callbacks @{ @ingroup private
### enet_packet_create(System.Void!System.Runtime.CompilerServices.IsConst*,System.UInt64,System.UInt32)
@}
### ENET_PACKET_FLAG_NO_ALLOCATE
packet will not allocate data, and user must supply it instead
### ENET_PACKET_FLAG_RELIABLE
packet must be received by the target peer and resend attempts should be * made until the packet is delivered
### ENET_PACKET_FLAG_UNSEQUENCED
packet will not be sequenced with other packets * not supported for reliable packets
### enet_socket_create(_ENetSocketType)
@defgroup socket ENet socket functions @{
### enet_time_get
@} @defgroup private ENet private implementation functions Returns the wall-time in milliseconds. Its initial value is unspecified unless otherwise set.
### enet_time_set(System.UInt32)
Sets the current wall-time in milliseconds.
### enet_uint8
@file types.h @brief type definitions for ENet
### ENetChecksumCallback
Callback that computes the checksum of the data held in buffers[0:bufferCount-1]
### ENetVersion
@}
### EVRNotificationStyle_Application
Used for notifications about overlay-level status. In Steam this is used for events like downloads completing.
### EVRNotificationStyle_Contact_Active
Used for notifications about contacts that are available and active. In Steam this is used for friends that are online and currently running a game.
### EVRNotificationStyle_Contact_Disabled
Used for notifications about contacts that are unknown or not available. In Steam this is used for friend invitations and offline friends.
### EVRNotificationStyle_Contact_Enabled
Used for notifications about contacts that are available but inactive. In Steam this is used for friends that are online but not playing a game.
### EVRNotificationStyle_None
Creates a notification with minimal external styling.
### EVRNotificationType_Persistent
Persistent notifications are shown to the user until they are hidden by calling RemoveNotification(). * They are used for things like phone calls and alarms that require user interaction.
### EVRNotificationType_Transient
Transient notifications are automatically hidden after a period of time set by the user. * They are used for things like information and chat messages that do not require user interaction.
### EVRNotificationType_Transient_SystemWithUserValue
System notifications are shown no matter what. It is expected, that the ulUserValue is used as ID. * If there is already a system notification in the queue with that ID it is not accepted into the queue * to prevent spamming with system notification
### Gdiplus.Region.IsVisible(Gdiplus.PointF!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Gdiplus.Graphics!System.Runtime.CompilerServices.IsConst*)
Hit testing operations
### LPALGENAUXILIARYEFFECTSLOTS
Auxiliary Slot object functions
### LPALGENEFFECTS
Context definitions to be used with alcCreateContext. These values must be unique and not conflict with other al context values. Listener definitions to be used with alListener functions. These values must be unique and not conflict with other al listener values. Source definitions to be used with alSource functions. These values must be unique and not conflict with other al source values. Effect object definitions to be used with alEffect functions. Effect parameter value definitions, ranges, and defaults appear farther down in this file. Auxiliary Slot object definitions to be used with alAuxiliaryEffectSlot functions. Value to be used as an Auxiliary Slot ID to disable a source send.. Filter object definitions to be used with alFilter functions. Effect object functions.
### LPALGENFILTERS
Filter object functions
### PFN_vmaAllocateDeviceMemoryFunction
Callback function called after successful vkAllocateMemory.
### PFN_vmaFreeDeviceMemoryFunction
Callback function called before vkFreeMemory.
### RC_MAX_TIMERS
The maximum number of timers. (Used for iterating timers.)
### RC_TIMER_BUILD_COMPACTHEIGHTFIELD
The time to build the compact heightfield. (See: #rcBuildCompactHeightfield)
### RC_TIMER_BUILD_CONTOURS
The total time to build the contours. (See: #rcBuildContours)
### RC_TIMER_BUILD_CONTOURS_SIMPLIFY
The time to simplify the contours. (See: #rcBuildContours)
### RC_TIMER_BUILD_CONTOURS_TRACE
The time to trace the boundaries of the contours. (See: #rcBuildContours)
### RC_TIMER_BUILD_DISTANCEFIELD
The total time to build the distance field. (See: #rcBuildDistanceField)
### RC_TIMER_BUILD_DISTANCEFIELD_BLUR
The time to blur the distance field. (See: #rcBuildDistanceField)
### RC_TIMER_BUILD_DISTANCEFIELD_DIST
The time to build the distances of the distance field. (See: #rcBuildDistanceField)
### RC_TIMER_BUILD_LAYERS
The time to build heightfield layers. (See: #rcBuildHeightfieldLayers)
### RC_TIMER_BUILD_POLYMESH
The time to build the polygon mesh. (See: #rcBuildPolyMesh)
### RC_TIMER_BUILD_POLYMESHDETAIL
The time to build the polygon mesh detail. (See: #rcBuildPolyMeshDetail)
### RC_TIMER_BUILD_REGIONS
The total time to build the regions. (See: #rcBuildRegions, #rcBuildRegionsMonotone)
### RC_TIMER_BUILD_REGIONS_EXPAND
The time to expand regions while applying the watershed algorithm. (See: #rcBuildRegions)
### RC_TIMER_BUILD_REGIONS_FILTER
The time to filter out small regions. (See: #rcBuildRegions, #rcBuildRegionsMonotone)
### RC_TIMER_BUILD_REGIONS_FLOOD
The time to flood regions while applying the watershed algorithm. (See: #rcBuildRegions)
### RC_TIMER_BUILD_REGIONS_WATERSHED
The total time to apply the watershed algorithm. (See: #rcBuildRegions)
### RC_TIMER_ERODE_AREA
The time to erode the walkable area. (See: #rcErodeWalkableArea)
### RC_TIMER_FILTER_BORDER
The time to filter ledge spans. (See: #rcFilterLedgeSpans)
### RC_TIMER_FILTER_LOW_OBSTACLES
The time to filter low obstacles. (See: #rcFilterLowHangingWalkableObstacles)
### RC_TIMER_FILTER_WALKABLE
The time to filter low height spans. (See: #rcFilterWalkableLowHeightSpans)
### RC_TIMER_MARK_BOX_AREA
The time to mark a box area. (See: #rcMarkBoxArea)
### RC_TIMER_MARK_CONVEXPOLY_AREA
The time to mark a convex polygon area. (See: #rcMarkConvexPolyArea)
### RC_TIMER_MARK_CYLINDER_AREA
The time to mark a cylinder area. (See: #rcMarkCylinderArea)
### RC_TIMER_MEDIAN_AREA
The time to apply the median filter. (See: #rcMedianFilterWalkableArea)
### RC_TIMER_MERGE_POLYMESH
The time to merge polygon meshes. (See: #rcMergePolyMeshes)
### RC_TIMER_MERGE_POLYMESHDETAIL
The time to merge polygon mesh details. (See: #rcMergePolyMeshDetails)
### RC_TIMER_RASTERIZE_TRIANGLES
The time to rasterize the triangles. (See: #rcRasterizeTriangle)
### RC_TIMER_TEMP
A user defined build time.
### RC_TIMER_TOTAL
The user defined total time of the build.
### rcAlloc(System.Int32,rcAllocHint)
Allocates a memory block. @param[in] size The size, in bytes of memory, to allocate. @param[in] hint A hint to the allocator on how long the memory is expected to be in use. @return A pointer to the beginning of the allocated memory block, or null if the allocation failed. @see rcFree
### rcAllocCompactHeightfield
Allocates a compact heightfield object using the Recast allocator. @return A compact heightfield that is ready for initialization, or null on failure. @ingroup recast @see rcBuildCompactHeightfield, rcFreeCompactHeightfield
### rcAllocContourSet
Allocates a contour set object using the Recast allocator. @return A contour set that is ready for initialization, or null on failure. @ingroup recast @see rcBuildContours, rcFreeContourSet
### rcAllocFunc
A memory allocation function. @see rcAllocSetCustom
### rcAllocHeightfield
@name Allocation Functions Functions used to allocate and de-allocate Recast objects. @see rcAllocSetCustom @{ Allocates a heightfield object using the Recast allocator. @return A heightfield that is ready for initialization, or null on failure. @ingroup recast @see rcCreateHeightfield, rcFreeHeightField
### rcAllocHeightfieldLayerSet
Allocates a heightfield layer set using the Recast allocator. @return A heightfield layer set that is ready for initialization, or null on failure. @ingroup recast @see rcBuildHeightfieldLayers, rcFreeHeightfieldLayerSet

## rcAllocHint
@} Provides hint values to the memory allocator on how long the memory is expected to be used.
### rcAllocPolyMesh
Allocates a polygon mesh object using the Recast allocator. @return A polygon mesh that is ready for initialization, or null on failure. @ingroup recast @see rcBuildPolyMesh, rcFreePolyMesh
### rcAllocPolyMeshDetail
Allocates a detail mesh object using the Recast allocator. @return A detail mesh that is ready for initialization, or null on failure. @ingroup recast @see rcBuildPolyMeshDetail, rcFreePolyMeshDetail
### rcAllocSetCustom(=FUNC:System.Void*(System.Int32,rcAllocHint),=FUNC:System.Void(System.Void*))
Sets the base custom allocation functions to be used by Recast. @param[in] allocFunc The memory allocation function to be used by #rcAlloc @param[in] freeFunc The memory de-allocation function to be used by #rcFree
### rcBuildCompactHeightfield(rcContext*,System.Int32!System.Runtime.CompilerServices.IsConst,System.Int32!System.Runtime.CompilerServices.IsConst,rcHeightfield*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,rcCompactHeightfield*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)
@} @name Compact Heightfield Functions @see rcCompactHeightfield @{ Builds a compact heightfield representing open space, from a heightfield representing solid space. @ingroup recast @param[in,out] ctx The build context to use during the operation. @param[in] walkableHeight Minimum floor to 'ceiling' height that will still allow the floor area to be considered walkable. [Limit: >= 3] [Units: vx] @param[in] walkableClimb Maximum ledge height that is considered to still be traversable. [Limit: >=0] [Units: vx] @param[in] hf The heightfield to be compacted. @param[out] chf The resulting compact heightfield. (Must be pre-allocated.) @returns True if the operation completed successfully.
### rcBuildContours(rcContext*,rcCompactHeightfield*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single!System.Runtime.CompilerServices.IsConst,System.Int32!System.Runtime.CompilerServices.IsConst,rcContourSet*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32!System.Runtime.CompilerServices.IsConst)
Builds a contour set from the region outlines in the provided compact heightfield. @ingroup recast @param[in,out] ctx The build context to use during the operation. @param[in] chf A fully built compact heightfield. @param[in] maxError The maximum distance a simplfied contour's border edges should deviate the original raw contour. [Limit: >=0] [Units: wu] @param[in] maxEdgeLen The maximum allowed length for contour edges along the border of the mesh. [Limit: >=0] [Units: vx] @param[out] cset The resulting contour set. (Must be pre-allocated.) @param[in] buildFlags The build flags. (See: #rcBuildContoursFlags) @returns True if the operation completed successfully.

## rcBuildContoursFlags
Contour build flags. @see rcBuildContours
### rcBuildDistanceField(rcContext*,rcCompactHeightfield*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)
Builds the distance field for the specified compact heightfield. @ingroup recast @param[in,out] ctx The build context to use during the operation. @param[in,out] chf A populated compact heightfield. @returns True if the operation completed successfully.
### rcBuildHeightfieldLayers(rcContext*,rcCompactHeightfield*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32!System.Runtime.CompilerServices.IsConst,System.Int32!System.Runtime.CompilerServices.IsConst,rcHeightfieldLayerSet*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)
@} @name Layer, Contour, Polymesh, and Detail Mesh Functions @see rcHeightfieldLayer, rcContourSet, rcPolyMesh, rcPolyMeshDetail @{ Builds a layer set from the specified compact heightfield. @ingroup recast @param[in,out] ctx The build context to use during the operation. @param[in] chf A fully built compact heightfield. @param[in] borderSize The size of the non-navigable border around the heightfield. [Limit: >=0] [Units: vx] @param[in] walkableHeight Minimum floor to 'ceiling' height that will still allow the floor area to be considered walkable. [Limit: >= 3] [Units: vx] @param[out] lset The resulting layer set. (Must be pre-allocated.) @returns True if the operation completed successfully.
### rcBuildPolyMesh(rcContext*,rcContourSet*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32!System.Runtime.CompilerServices.IsConst,rcPolyMesh*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)
Builds a polygon mesh from the provided contours. @ingroup recast @param[in,out] ctx The build context to use during the operation. @param[in] cset A fully built contour set. @param[in] nvp The maximum number of vertices allowed for polygons generated during the contour to polygon conversion process. [Limit: >= 3] @param[out] mesh The resulting polygon mesh. (Must be re-allocated.) @returns True if the operation completed successfully.
### rcBuildPolyMeshDetail(rcContext*,rcPolyMesh!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,rcCompactHeightfield!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single!System.Runtime.CompilerServices.IsConst,System.Single!System.Runtime.CompilerServices.IsConst,rcPolyMeshDetail*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)
Builds a detail mesh from the provided polygon mesh. @ingroup recast @param[in,out] ctx The build context to use during the operation. @param[in] mesh A fully built polygon mesh. @param[in] chf The compact heightfield used to build the polygon mesh. @param[in] sampleDist Sets the distance to use when samping the heightfield. [Limit: >=0] [Units: wu] @param[in] sampleMaxError The maximum distance the detail mesh surface should deviate from heightfield data. [Limit: >=0] [Units: wu] @param[out] dmesh The resulting detail mesh. (Must be pre-allocated.) @returns True if the operation completed successfully.
### rcBuildRegions(rcContext*,rcCompactHeightfield*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32!System.Runtime.CompilerServices.IsConst,System.Int32!System.Runtime.CompilerServices.IsConst,System.Int32!System.Runtime.CompilerServices.IsConst)
Builds region data for the heightfield using watershed partitioning. @ingroup recast @param[in,out] ctx The build context to use during the operation. @param[in,out] chf A populated compact heightfield. @param[in] borderSize The size of the non-navigable border around the heightfield. [Limit: >=0] [Units: vx] @param[in] minRegionArea The minimum number of cells allowed to form isolated island areas. [Limit: >=0] [Units: vx]. @param[in] mergeRegionArea Any regions with a span count smaller than this value will, if possible, be merged with larger regions. [Limit: >=0] [Units: vx] @returns True if the operation completed successfully.
### rcBuildRegionsMonotone(rcContext*,rcCompactHeightfield*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32!System.Runtime.CompilerServices.IsConst,System.Int32!System.Runtime.CompilerServices.IsConst,System.Int32!System.Runtime.CompilerServices.IsConst)
Builds region data for the heightfield using simple monotone partitioning. @ingroup recast @param[in,out] ctx The build context to use during the operation. @param[in,out] chf A populated compact heightfield. @param[in] borderSize The size of the non-navigable border around the heightfield. [Limit: >=0] [Units: vx] @param[in] minRegionArea The minimum number of cells allowed to form isolated island areas. [Limit: >=0] [Units: vx]. @param[in] mergeRegionArea Any regions with a span count smaller than this value will, if possible, be merged with larger regions. [Limit: >=0] [Units: vx] @returns True if the operation completed successfully.
### rcCalcBounds(System.Single!System.Runtime.CompilerServices.IsConst*,System.Int32,System.Single*,System.Single*)
@} @name Heightfield Functions @see rcHeightfield @{ Calculates the bounding box of an array of vertices. @ingroup recast @param[in] verts An array of vertices. [(x, y, z) * @p nv] @param[in] nv The number of vertices in the @p verts array. @param[out] bmin The minimum bounds of the AABB. [(x, y, z)] [Units: wu] @param[out] bmax The maximum bounds of the AABB. [(x, y, z)] [Units: wu]
### rcCalcGridSize(System.Single!System.Runtime.CompilerServices.IsConst*,System.Single!System.Runtime.CompilerServices.IsConst*,System.Single,System.Int32*,System.Int32*)
Calculates the grid size based on the bounding box and grid cell size. @ingroup recast @param[in] bmin The minimum bounds of the AABB. [(x, y, z)] [Units: wu] @param[in] bmax The maximum bounds of the AABB. [(x, y, z)] [Units: wu] @param[in] cs The xz-plane cell size. [Limit: > 0] [Units: wu] @param[out] w The width along the x-axis. [Limit: >= 0] [Units: vx] @param[out] h The height along the z-axis. [Limit: >= 0] [Units: vx]

## rcCompactCell
Provides information on the content of a cell column in a compact heightfield.

## rcCompactHeightfield
A compact, static heightfield representing unobstructed space. @ingroup recast

## rcCompactSpan
Represents a span of unobstructed space within a compact heightfield.

## rcConfig
Specifies a configuration to use when performing Recast builds. @ingroup recast
### rcConfig.bmax
The maximum bounds of the field's AABB. [(x, y, z)] [Units: wu]
### rcConfig.bmin
The minimum bounds of the field's AABB. [(x, y, z)] [Units: wu]
### rcConfig.borderSize
The size of the non-navigable border around the heightfield. [Limit: >=0] [Units: vx]
### rcConfig.ch
The y-axis cell size to use for fields. [Limit: > 0] [Units: wu]
### rcConfig.cs
The xz-plane cell size to use for fields. [Limit: > 0] [Units: wu]
### rcConfig.detailSampleDist
Sets the sampling distance to use when generating the detail mesh. (For height detail only.) [Limits: 0 or >= 0.9] [Units: wu]
### rcConfig.detailSampleMaxError
The maximum distance the detail mesh surface should deviate from heightfield data. (For height detail only.) [Limit: >=0] [Units: wu]
### rcConfig.height
The height of the field along the z-axis. [Limit: >= 0] [Units: vx]
### rcConfig.maxEdgeLen
The maximum allowed length for contour edges along the border of the mesh. [Limit: >=0] [Units: vx]
### rcConfig.maxSimplificationError
The maximum distance a simplfied contour's border edges should deviate the original raw contour. [Limit: >=0] [Units: wu]
### rcConfig.maxVertsPerPoly
The maximum number of vertices allowed for polygons generated during the contour to polygon conversion process. [Limit: >= 3]
### rcConfig.mergeRegionArea
Any regions with a span count smaller than this value will, if possible, be merged with larger regions. [Limit: >=0] [Units: vx]
### rcConfig.minRegionArea
The minimum number of cells allowed to form isolated island areas. [Limit: >=0] [Units: vx]
### rcConfig.tileSize
The width/height size of tile's on the xz-plane. [Limit: >= 0] [Units: vx]
### rcConfig.walkableClimb
Maximum ledge height that is considered to still be traversable. [Limit: >=0] [Units: vx]
### rcConfig.walkableHeight
Minimum floor to 'ceiling' height that will still allow the floor area to be considered walkable. [Limit: >= 3] [Units: vx]
### rcConfig.walkableRadius
The distance to erode/shrink the walkable area of the heightfield away from obstructions. [Limit: >=0] [Units: vx]
### rcConfig.width
The width of the field along the x-axis. [Limit: >= 0] [Units: vx]

## rcContext
Provides an interface for optional logging and performance tracking of the Recast build process. @ingroup recast
### rcContext.Constructor(System.Boolean)
Contructor. @param[in] state TRUE if the logging and performance timers should be enabled. [Default: true]
### rcContext.doGetAccumulatedTime(rcTimerLabel!System.Runtime.CompilerServices.IsConst)
Returns the total accumulated time of the specified performance timer. @param[in] label The category of the timer. @return The accumulated time of the timer, or -1 if timers are disabled or the timer has never been started.
### rcContext.doLog(rcLogCategory!System.Runtime.CompilerServices.IsConst,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Int32!System.Runtime.CompilerServices.IsConst)
Logs a message. @param[in] category The category of the message. @param[in] msg The formatted message. @param[in] len The length of the formatted message.
### rcContext.doResetLog
Clears all log entries.
### rcContext.doResetTimers
Clears all timers. (Resets all to unused.)
### rcContext.doStartTimer(rcTimerLabel!System.Runtime.CompilerServices.IsConst)
Starts the specified performance timer. @param[in] label The category of timer.
### rcContext.doStopTimer(rcTimerLabel!System.Runtime.CompilerServices.IsConst)
Stops the specified performance timer. @param[in] label The category of the timer.
### rcContext.enableLog(System.Boolean)
Enables or disables logging. @param[in] state TRUE if logging should be enabled.
### rcContext.enableTimer(System.Boolean)
Enables or disables the performance timers. @param[in] state TRUE if timers should be enabled.
### rcContext.getAccumulatedTime(rcTimerLabel!System.Runtime.CompilerServices.IsConst)
Returns the total accumulated time of the specified performance timer. @param label The category of the timer. @return The accumulated time of the timer, or -1 if timers are disabled or the timer has never been started.
### rcContext.log(rcLogCategory!System.Runtime.CompilerServices.IsConst,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,BTEllipsis)
Logs a message. @param[in] category The category of the message. @param[in] format The message.
### rcContext.m_logEnabled
True if logging is enabled.
### rcContext.m_timerEnabled
True if the performance timers are enabled.
### rcContext.resetLog
Clears all log entries.
### rcContext.resetTimers
Clears all peformance timers. (Resets all to unused.)
### rcContext.startTimer(rcTimerLabel!System.Runtime.CompilerServices.IsConst)
Starts the specified performance timer. @param label The category of timer.
### rcContext.stopTimer(rcTimerLabel!System.Runtime.CompilerServices.IsConst)
Stops the specified performance timer. @param label The category of the timer.

## rcContour
Represents a simple, non-overlapping contour in field space.

## rcContourSet
Represents a group of related contours. @ingroup recast
### rcCopyPolyMesh(rcContext*,rcPolyMesh!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,rcPolyMesh*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)
Copies the poly mesh data from src to dst. @ingroup recast @param[in,out] ctx The build context to use during the operation. @param[in] src The source mesh to copy from. @param[out] dst The resulting detail mesh. (Must be pre-allocated, must be empty mesh.) @returns True if the operation completed successfully.
### rcCreateHeightfield(rcContext*,rcHeightfield*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,System.Int32,System.Single!System.Runtime.CompilerServices.IsConst*,System.Single!System.Runtime.CompilerServices.IsConst*,System.Single,System.Single)
Initializes a new heightfield. @ingroup recast @param[in,out] ctx The build context to use during the operation. @param[in,out] hf The allocated heightfield to initialize. @param[in] width The width of the field along the x-axis. [Limit: >= 0] [Units: vx] @param[in] height The height of the field along the z-axis. [Limit: >= 0] [Units: vx] @param[in] bmin The minimum bounds of the field's AABB. [(x, y, z)] [Units: wu] @param[in] bmax The maximum bounds of the field's AABB. [(x, y, z)] [Units: wu] @param[in] cs The xz-plane cell size to use for the field. [Limit: > 0] [Units: wu] @param[in] ch The y-axis cell size to use for field. [Limit: > 0] [Units: wu]
### rcFilterLedgeSpans(rcContext*,System.Int32!System.Runtime.CompilerServices.IsConst,System.Int32!System.Runtime.CompilerServices.IsConst,rcHeightfield*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)
Marks spans that are ledges as not-walkable. @ingroup recast @param[in,out] ctx The build context to use during the operation. @param[in] walkableHeight Minimum floor to 'ceiling' height that will still allow the floor area to be considered walkable. [Limit: >= 3] [Units: vx] @param[in] walkableClimb Maximum ledge height that is considered to still be traversable. [Limit: >=0] [Units: vx] @param[in,out] solid A fully built heightfield. (All spans have been added.)
### rcFilterLowHangingWalkableObstacles(rcContext*,System.Int32!System.Runtime.CompilerServices.IsConst,rcHeightfield*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)
Marks non-walkable spans as walkable if their maximum is within @p walkableClimp of a walkable neihbor. @ingroup recast @param[in,out] ctx The build context to use during the operation. @param[in] walkableClimb Maximum ledge height that is considered to still be traversable. [Limit: >=0] [Units: vx] @param[in,out] solid A fully built heightfield. (All spans have been added.)
### rcFilterWalkableLowHeightSpans(rcContext*,System.Int32,rcHeightfield*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)
Marks walkable spans as not walkable if the clearence above the span is less than the specified height. @ingroup recast @param[in,out] ctx The build context to use during the operation. @param[in] walkableHeight Minimum floor to 'ceiling' height that will still allow the floor area to be considered walkable. [Limit: >= 3] [Units: vx] @param[in,out] solid A fully built heightfield. (All spans have been added.)
### rcFree(System.Void*)
Deallocates a memory block. @param[in] ptr A pointer to a memory block previously allocated using #rcAlloc. @see rcAlloc
### rcFreeCompactHeightfield(rcCompactHeightfield*)
Frees the specified compact heightfield object using the Recast allocator. @param[in] chf A compact heightfield allocated using #rcAllocCompactHeightfield @ingroup recast @see rcAllocCompactHeightfield
### rcFreeContourSet(rcContourSet*)
Frees the specified contour set using the Recast allocator. @param[in] cset A contour set allocated using #rcAllocContourSet @ingroup recast @see rcAllocContourSet
### rcFreeFunc
A memory deallocation function. @param[in] ptr A pointer to a memory block previously allocated using #rcAllocFunc. @see rcAllocSetCustom
### rcFreeHeightField(rcHeightfield*)
Frees the specified heightfield object using the Recast allocator. @param[in] hf A heightfield allocated using #rcAllocHeightfield @ingroup recast @see rcAllocHeightfield
### rcFreeHeightfieldLayerSet(rcHeightfieldLayerSet*)
Frees the specified heightfield layer set using the Recast allocator. @param[in] lset A heightfield layer set allocated using #rcAllocHeightfieldLayerSet @ingroup recast @see rcAllocHeightfieldLayerSet
### rcFreePolyMesh(rcPolyMesh*)
Frees the specified polygon mesh using the Recast allocator. @param[in] pmesh A polygon mesh allocated using #rcAllocPolyMesh @ingroup recast @see rcAllocPolyMesh
### rcFreePolyMeshDetail(rcPolyMeshDetail*)
Frees the specified detail mesh using the Recast allocator. @param[in] dmesh A detail mesh allocated using #rcAllocPolyMeshDetail @ingroup recast @see rcAllocPolyMeshDetail
### rcGetHeightFieldSpanCount(rcContext*,rcHeightfield*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)
Returns the number of spans contained in the specified heightfield. @ingroup recast @param[in,out] ctx The build context to use during the operation. @param[in] hf An initialized heightfield. @returns The number of spans in the heightfield.

## rcHeightfield
A dynamic heightfield representing obstructed space. @ingroup recast

## rcHeightfieldLayer
Represents a heightfield layer within a layer set. @see rcHeightfieldLayerSet

## rcHeightfieldLayerSet
Represents a set of heightfield layers. @ingroup recast @see rcAllocHeightfieldLayerSet, rcFreeHeightfieldLayerSet

## rcIntArray
A simple dynamic array of integers.
### rcIntArray.Constructor
Constructs an instance with an initial array size of zero.
### rcIntArray.Constructor(System.Int32)
Constructs an instance initialized to the specified size. @param[in] n The initial size of the integer array.
### rcIntArray.op_Subscript(System.Int32)
The value at the specified array index. @warning Does not provide overflow protection. @param[in] i The index of the value.
### rcIntArray.op_Subscript(System.Int32)
The value at the specified array index. @warning Does not provide overflow protection. @param[in] i The index of the value.
### rcIntArray.pop
Returns the value at the end of the array and reduces the size by one. @return The value at the end of the array.
### rcIntArray.push(System.Int32)
Push the specified integer onto the end of the array and increases the size by one. @param[in] item The new value.
### rcIntArray.resize(System.Int32)
Specifies the new size of the integer array. @param[in] n The new size of the integer array.
### rcIntArray.size
The current size of the integer array.

## rcLogCategory
Recast log categories. @see rcContext
### rcMedianFilterWalkableArea(rcContext*,rcCompactHeightfield*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)
Applies a median filter to walkable area types (based on area id), removing noise. @ingroup recast @param[in,out] ctx The build context to use during the operation. @param[in,out] chf A populated compact heightfield. @returns True if the operation completed successfully.
### rcMergePolyMeshDetails(rcContext*,rcPolyMeshDetail**,System.Int32!System.Runtime.CompilerServices.IsConst,rcPolyMeshDetail*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)
Merges multiple detail meshes into a single detail mesh. @ingroup recast @param[in,out] ctx The build context to use during the operation. @param[in] meshes An array of detail meshes to merge. [Size: @p nmeshes] @param[in] nmeshes The number of detail meshes in the meshes array. @param[out] mesh The resulting detail mesh. (Must be pre-allocated.) @returns True if the operation completed successfully.
### rcMergePolyMeshes(rcContext*,rcPolyMesh**,System.Int32!System.Runtime.CompilerServices.IsConst,rcPolyMesh*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)
Merges multiple polygon meshes into a single mesh. @ingroup recast @param[in,out] ctx The build context to use during the operation. @param[in] meshes An array of polygon meshes to merge. [Size: @p nmeshes] @param[in] nmeshes The number of polygon meshes in the meshes array. @param[in] mesh The resulting polygon mesh. (Must be pre-allocated.) @returns True if the operation completed successfully.
### rcOffsetPoly(System.Single!System.Runtime.CompilerServices.IsConst*,System.Int32!System.Runtime.CompilerServices.IsConst,System.Single!System.Runtime.CompilerServices.IsConst,System.Single*,System.Int32!System.Runtime.CompilerServices.IsConst)
Helper function to offset voncex polygons for rcMarkConvexPolyArea. @ingroup recast @param[in] verts The vertices of the polygon [Form: (x, y, z) * @p nverts] @param[in] nverts The number of vertices in the polygon. @param[out] outVerts The offset vertices (should hold up to 2 * @p nverts) [Form: (x, y, z) * return value] @param[in] maxOutVerts The max number of vertices that can be stored to @p outVerts. @returns Number of vertices in the offset polygon or 0 if too few vertices in @p outVerts.

## rcPolyMesh
Represents a polygon mesh suitable for use in building a navigation mesh. @ingroup recast

## rcPolyMeshDetail
Contains triangle meshes that represent detailed height data associated with the polygons in its associated polygon mesh object. @ingroup recast

## rcSpan
Represents a span in a heightfield. @see rcHeightfield

## rcSpanPool
A memory pool used for quick allocation of spans within a heightfield. @see rcHeightfield
### rcSqrt(System.Single)
Returns the square root of the value. @param[in] x The value. @return The square root of the vlaue.

## rcTimerLabel
Recast performance timer categories. @see rcContext
### rcVadd(System.Single*,System.Single!System.Runtime.CompilerServices.IsConst*,System.Single!System.Runtime.CompilerServices.IsConst*)
Performs a vector addition. (@p v1 + @p v2) @param[out] dest The result vector. [(x, y, z)] @param[in] v1 The base vector. [(x, y, z)] @param[in] v2 The vector to add to @p v1. [(x, y, z)]
### rcVcopy(System.Single*,System.Single!System.Runtime.CompilerServices.IsConst*)
Performs a vector copy. @param[out] dest The result. [(x, y, z)] @param[in] v The vector to copy. [(x, y, z)]
### rcVcross(System.Single*,System.Single!System.Runtime.CompilerServices.IsConst*,System.Single!System.Runtime.CompilerServices.IsConst*)
@} @name Vector helper functions. @{ Derives the cross product of two vectors. (@p v1 x @p v2) @param[out] dest The cross product. [(x, y, z)] @param[in] v1 A Vector [(x, y, z)] @param[in] v2 A vector [(x, y, z)]
### rcVdist(System.Single!System.Runtime.CompilerServices.IsConst*,System.Single!System.Runtime.CompilerServices.IsConst*)
Returns the distance between two points. @param[in] v1 A point. [(x, y, z)] @param[in] v2 A point. [(x, y, z)] @return The distance between the two points.
### rcVdistSqr(System.Single!System.Runtime.CompilerServices.IsConst*,System.Single!System.Runtime.CompilerServices.IsConst*)
Returns the square of the distance between two points. @param[in] v1 A point. [(x, y, z)] @param[in] v2 A point. [(x, y, z)] @return The square of the distance between the two points.
### rcVdot(System.Single!System.Runtime.CompilerServices.IsConst*,System.Single!System.Runtime.CompilerServices.IsConst*)
Derives the dot product of two vectors. (@p v1 . @p v2) @param[in] v1 A Vector [(x, y, z)] @param[in] v2 A vector [(x, y, z)] @return The dot product.
### rcVmad(System.Single*,System.Single!System.Runtime.CompilerServices.IsConst*,System.Single!System.Runtime.CompilerServices.IsConst*,System.Single!System.Runtime.CompilerServices.IsConst)
Performs a scaled vector addition. (@p v1 + (@p v2 * @p s)) @param[out] dest The result vector. [(x, y, z)] @param[in] v1 The base vector. [(x, y, z)] @param[in] v2 The vector to scale and add to @p v1. [(x, y, z)] @param[in] s The amount to scale @p v2 by before adding to @p v1.
### rcVmax(System.Single*,System.Single!System.Runtime.CompilerServices.IsConst*)
Selects the maximum value of each element from the specified vectors. @param[in,out] mx A vector. (Will be updated with the result.) [(x, y, z)] @param[in] v A vector. [(x, y, z)]
### rcVmin(System.Single*,System.Single!System.Runtime.CompilerServices.IsConst*)
Selects the minimum value of each element from the specified vectors. @param[in,out] mn A vector. (Will be updated with the result.) [(x, y, z)] @param[in] v A vector. [(x, y, z)]
### rcVnormalize(System.Single*)
Normalizes the vector. @param[in,out] v The vector to normalize. [(x, y, z)]
### rcVsub(System.Single*,System.Single!System.Runtime.CompilerServices.IsConst*,System.Single!System.Runtime.CompilerServices.IsConst*)
Performs a vector subtraction. (@p v1 - @p v2) @param[out] dest The result vector. [(x, y, z)] @param[in] v1 The base vector. [(x, y, z)] @param[in] v2 The vector to subtract from @p v1. [(x, y, z)]

## monostate
\brief Used to represent an optional with no data; essentially a bool

## nullopt_t
\brief A tag type to represent an empty optional
### Turbo.CreateTerrain(world, tilesx, tilesy, patchsize, LODLevels)

Creates a new terrain object.

| Name | Description |
| ---- | ----------- |
| world | *std.shared_ptr<Turbo.World>*<br>The world to create the terrain in. This can be NULL. |
| tilesx | *System.Int32!System.Runtime.CompilerServices.IsConst*<br>The number of horizontal tiles. |
| tilesy | *System.Int32!System.Runtime.CompilerServices.IsConst*<br>The number of vertical tiles. |
| patchsize | *System.Int32!System.Runtime.CompilerServices.IsConst*<br>Resolution of one patch. |
| LODLevels | *System.Int32!System.Runtime.CompilerServices.IsConst*<br>Number of LODs. |

#### Returns

Returns a new terrain.


## Entity

The base class for all types of 3D objects.

### SetPosition(x, y, z, global)

Sets the entity position.

| Name | Description |
| ---- | ----------- |
| x | *System.Single!System.Runtime.CompilerServices.IsConst*<br>X component of the position. |
| y | *System.Single!System.Runtime.CompilerServices.IsConst*<br>Y component of the position. |
| z | *System.Single!System.Runtime.CompilerServices.IsConst*<br>Z component of the position. |
| global | *System.Boolean!System.Runtime.CompilerServices.IsConst*<br>If set to true, global space is used, otherwise local space is used. |

### SetPosition(position, global)

Sets the entity position.

| Name | Description |
| ---- | ----------- |
| position | *Turbo.dVec3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced*<br> |
| global | *System.Boolean!System.Runtime.CompilerServices.IsConst*<br> |

### Turbo.NavMeshDebugger.begin(duDebugDrawPrimitives,System.Single)
Begin drawing primitives. @param prim [in] primitive type to draw, one of rcDebugDrawPrimitives. @param size [in] size of a primitive, applies to point size and line width only.
### Turbo.NavMeshDebugger.end
End drawing primitives.
### Turbo.NavMeshDebugger.vertex(System.Single!System.Runtime.CompilerServices.IsConst,System.Single!System.Runtime.CompilerServices.IsConst,System.Single!System.Runtime.CompilerServices.IsConst,System.UInt32,System.Single!System.Runtime.CompilerServices.IsConst,System.Single!System.Runtime.CompilerServices.IsConst)
Submit a vertex @param x,y,z [in] position of the verts. @param color [in] color of the verts.
### Turbo.NavMeshDebugger.vertex(System.Single!System.Runtime.CompilerServices.IsConst,System.Single!System.Runtime.CompilerServices.IsConst,System.Single!System.Runtime.CompilerServices.IsConst,System.UInt32)
Submit a vertex @param x,y,z [in] position of the verts. @param color [in] color of the verts.
### Turbo.NavMeshDebugger.vertex(System.Single!System.Runtime.CompilerServices.IsConst*,System.UInt32,System.Single!System.Runtime.CompilerServices.IsConst*)
Submit a vertex @param pos [in] position of the verts. @param color [in] color of the verts.
### Turbo.NavMeshDebugger.vertex(System.Single!System.Runtime.CompilerServices.IsConst*,System.UInt32)
Submit a vertex @param pos [in] position of the verts. @param color [in] color of the verts.

## Terrain

The terrain class is used to simulate large outdoor landscapes.

### GetNormal(x, y)

Gets the normal at the spcified terrain point.

| Name | Description |
| ---- | ----------- |
| x | *System.Int32!System.Runtime.CompilerServices.IsConst*<br> |
| y | *System.Int32!System.Runtime.CompilerServices.IsConst*<br> |

#### Returns



### GetSlope(x, y)

Gets the slope at the spcified terrain point.

| Name | Description |
| ---- | ----------- |
| x | *System.Int32!System.Runtime.CompilerServices.IsConst*<br> |
| y | *System.Int32!System.Runtime.CompilerServices.IsConst*<br> |

#### Returns

Returns the slope in the range from zero to 90 degrees.

### SetElevation(x, y, height)

Sets the elevation of one terrain point.

| Name | Description |
| ---- | ----------- |
| x | *System.Int32!System.Runtime.CompilerServices.IsConst*<br>X position of the point to modify. |
| y | *System.Int32!System.Runtime.CompilerServices.IsConst*<br>Y position of the point to modify. |
| height | *System.Single!System.Runtime.CompilerServices.IsConst*<br>Height to set in global space. |

### SetHeight(x, y, height)

Sets the height of one terrain point.

| Name | Description |
| ---- | ----------- |
| x | *System.Int32!System.Runtime.CompilerServices.IsConst*<br>X position of the point to modify. |
| y | *System.Int32!System.Runtime.CompilerServices.IsConst*<br>Y position of the point to modify. |
| height | *System.Single!System.Runtime.CompilerServices.IsConst*<br>Height to set, in the range -1.0 to +1.0. |

### UpdateNormals

Updates the normals of the entire terrain.

### UpdateNormals(x, y, width, height)

Updates the terrain normals over a range of points.

| Name | Description |
| ---- | ----------- |
| x | *System.Int32!System.Runtime.CompilerServices.IsConst*<br> |
| y | *System.Int32!System.Runtime.CompilerServices.IsConst*<br> |
| width | *System.Int32!System.Runtime.CompilerServices.IsConst*<br> |
| height | *System.Int32!System.Runtime.CompilerServices.IsConst*<br> |


## UpdateFlags
Crowd agent update flags. @ingroup crowd @see dtCrowdAgentParams::updateFlags
### VMA_ALLOCATION_CREATE_CAN_BECOME_LOST_BIT
Allocation created with this flag can become lost as a result of another allocation with #VMA_ALLOCATION_CREATE_CAN_MAKE_OTHER_LOST_BIT flag, so you must check it before use. To check if allocation is not lost, call vmaGetAllocationInfo() and check if VmaAllocationInfo::deviceMemory is not `VK_NULL_HANDLE`. For details about supporting lost allocations, see Lost Allocations chapter of User Guide on Main Page. You should not use this flag together with #VMA_ALLOCATION_CREATE_MAPPED_BIT.
### VMA_ALLOCATION_CREATE_CAN_MAKE_OTHER_LOST_BIT
While creating allocation using this flag, other allocations that were created with flag #VMA_ALLOCATION_CREATE_CAN_BECOME_LOST_BIT can become lost. For details about supporting lost allocations, see Lost Allocations chapter of User Guide on Main Page.
### VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT
\brief Set this flag if the allocation should have its own memory block. Use it for special, big resources, like fullscreen images used as attachments. You should not use this flag if VmaAllocationCreateInfo::pool is not null.
### VMA_ALLOCATION_CREATE_DONT_BIND_BIT
Create both buffer/image and allocation, but don't bind them together. It is useful when you want to bind yourself to do some more advanced binding, e.g. using some extensions. The flag is meaningful only with functions that bind by default: vmaCreateBuffer(), vmaCreateImage(). Otherwise it is ignored.
### VMA_ALLOCATION_CREATE_MAPPED_BIT
\brief Set this flag to use a memory that will be persistently mapped and retrieve pointer to it. Pointer to mapped memory will be returned through VmaAllocationInfo::pMappedData. Is it valid to use this flag for allocation made from memory type that is not `HOST_VISIBLE`. This flag is then ignored and memory is not mapped. This is useful if you need an allocation that is efficient to use on GPU (`DEVICE_LOCAL`) and still want to map it directly if possible on platforms that support it (e.g. Intel GPU). You should not use this flag together with #VMA_ALLOCATION_CREATE_CAN_BECOME_LOST_BIT.
### VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT
\brief Set this flag to only try to allocate from existing `VkDeviceMemory` blocks and never create new such block. If new allocation cannot be placed in any of the existing blocks, allocation fails with `VK_ERROR_OUT_OF_DEVICE_MEMORY` error. You should not use #VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT and #VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT at the same time. It makes no sense. If VmaAllocationCreateInfo::pool is not null, this flag is implied and ignored.
### VMA_ALLOCATION_CREATE_STRATEGY_BEST_FIT_BIT
Allocation strategy that chooses smallest possible free range for the allocation.
### VMA_ALLOCATION_CREATE_STRATEGY_FIRST_FIT_BIT
Allocation strategy that chooses first suitable free range for the allocation. "First" doesn't necessarily means the one with smallest offset in memory, but rather the one that is easiest and fastest to find.
### VMA_ALLOCATION_CREATE_STRATEGY_MASK
A bit mask to extract only `STRATEGY` bits from entire set of flags.
### VMA_ALLOCATION_CREATE_STRATEGY_MIN_FRAGMENTATION_BIT
Allocation strategy that tries to minimize memory fragmentation.
### VMA_ALLOCATION_CREATE_STRATEGY_MIN_MEMORY_BIT
Allocation strategy that tries to minimize memory usage.
### VMA_ALLOCATION_CREATE_STRATEGY_MIN_TIME_BIT
Allocation strategy that tries to minimize allocation time.
### VMA_ALLOCATION_CREATE_STRATEGY_WORST_FIT_BIT
Allocation strategy that chooses biggest possible free range for the allocation.
### VMA_ALLOCATION_CREATE_UPPER_ADDRESS_BIT
Allocation will be created from upper stack in a double stack pool. This flag is only allowed for custom pools created with #VMA_POOL_CREATE_LINEAR_ALGORITHM_BIT flag.
### VMA_ALLOCATION_CREATE_USER_DATA_COPY_STRING_BIT
Set this flag to treat VmaAllocationCreateInfo::pUserData as pointer to a null-terminated string. Instead of copying pointer value, a local copy of the string is made and stored in allocation's `pUserData`. The string is automatically freed together with the allocation. It is also used in vmaBuildStatsString().
### VMA_ALLOCATOR_CREATE_EXTERNALLY_SYNCHRONIZED_BIT
\brief Allocator and all objects created from it will not be synchronized internally, so you must guarantee they are used from only one thread at a time or synchronized externally by you. Using this flag may increase performance because internal mutexes are not used.
### VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT
\brief Enables usage of VK_KHR_dedicated_allocation extension. Using this extenion will automatically allocate dedicated blocks of memory for some buffers and images instead of suballocating place for them out of bigger memory blocks (as if you explicitly used #VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT flag) when it is recommended by the driver. It may improve performance on some GPUs. You may set this flag only if you found out that following device extensions are supported, you enabled them while creating Vulkan device passed as VmaAllocatorCreateInfo::device, and you want them to be used internally by this library: - VK_KHR_get_memory_requirements2 - VK_KHR_dedicated_allocation When this flag is set, you can experience following warnings reported by Vulkan validation layer. You can ignore them. > vkBindBufferMemory(): Binding memory to buffer 0x2d but vkGetBufferMemoryRequirements() has not been called on that buffer.
### VMA_MEMORY_USAGE_CPU_ONLY
Memory will be mappable on host. It usually means CPU (system) memory. Guarantees to be `HOST_VISIBLE` and `HOST_COHERENT`. CPU access is typically uncached. Writes may be write-combined. Resources created in this pool may still be accessible to the device, but access to them can be slow. It is roughly equivalent of `D3D12_HEAP_TYPE_UPLOAD`. Usage: Staging copy of resources used as transfer source.
### VMA_MEMORY_USAGE_CPU_TO_GPU
Memory that is both mappable on host (guarantees to be `HOST_VISIBLE`) and preferably fast to access by GPU. CPU access is typically uncached. Writes may be write-combined. Usage: Resources written frequently by host (dynamic), read by device. E.g. textures, vertex buffers, uniform buffers updated every frame or every draw call.
### VMA_MEMORY_USAGE_GPU_ONLY
Memory will be used on device only, so fast access from the device is preferred. It usually means device-local GPU (video) memory. No need to be mappable on host. It is roughly equivalent of `D3D12_HEAP_TYPE_DEFAULT`. Usage: - Resources written and read by device, e.g. images used as attachments. - Resources transferred from host once (immutable) or infrequently and read by device multiple times, e.g. textures to be sampled, vertex buffers, uniform (constant) buffers, and majority of other types of resources used on GPU. Allocation may still end up in `HOST_VISIBLE` memory on some implementations. In such case, you are free to map it. You can use #VMA_ALLOCATION_CREATE_MAPPED_BIT with this usage type.
### VMA_MEMORY_USAGE_GPU_TO_CPU
Memory mappable on host (guarantees to be `HOST_VISIBLE`) and cached. It is roughly equivalent of `D3D12_HEAP_TYPE_READBACK`. Usage: - Resources written by device, read by host - results of some computations, e.g. screen capture, average scene luminance for HDR tone mapping. - Any resources read or accessed randomly on host, e.g. CPU-side copy of vertex buffer used as source of transfer, but also used for collision detection.
### VMA_MEMORY_USAGE_UNKNOWN
No intended memory usage specified. Use other members of VmaAllocationCreateInfo to specify your requirements.
### VMA_POOL_CREATE_ALGORITHM_MASK
Bit mask to extract only `ALGORITHM` bits from entire set of flags.
### VMA_POOL_CREATE_BUDDY_ALGORITHM_BIT
\brief Enables alternative, buddy allocation algorithm in this pool. It operates on a tree of blocks, each having size that is a power of two and a half of its parent's size. Comparing to default algorithm, this one provides faster allocation and deallocation and decreased external fragmentation, at the expense of more memory wasted (internal fragmentation). For more details, see [Buddy allocation algorithm](@ref buddy_algorithm).
### VMA_POOL_CREATE_IGNORE_BUFFER_IMAGE_GRANULARITY_BIT
\brief Use this flag if you always allocate only buffers and linear images or only optimal images out of this pool and so Buffer-Image Granularity can be ignored. This is an optional optimization flag. If you always allocate using vmaCreateBuffer(), vmaCreateImage(), vmaAllocateMemoryForBuffer(), then you don't need to use it because allocator knows exact type of your allocations so it can handle Buffer-Image Granularity in the optimal way. If you also allocate using vmaAllocateMemoryForImage() or vmaAllocateMemory(), exact type of such allocations is not known, so allocator must be conservative in handling Buffer-Image Granularity, which can lead to suboptimal allocation (wasted memory). In that case, if you can make sure you always allocate only buffers and linear images or only optimal images out of this pool, use this flag to make allocator disregard Buffer-Image Granularity and so make allocations faster and more optimal.
### VMA_POOL_CREATE_LINEAR_ALGORITHM_BIT
\brief Enables alternative, linear allocation algorithm in this pool. Specify this flag to enable linear allocation algorithm, which always creates new allocations after last one and doesn't reuse space from allocations freed in between. It trades memory consumption for simplified algorithm and data structure, which has better performance and uses less memory for metadata. By using this flag, you can achieve behavior of free-at-once, stack, ring buffer, and double stack. For details, see documentation chapter \ref linear_algorithm. When using this flag, you must specify VmaPoolCreateInfo::maxBlockCount == 1 (or 0 for default). For more details, see [Linear allocation algorithm](@ref linear_algorithm).
### VMA_RECORD_FLUSH_AFTER_CALL_BIT
\brief Enables flush after recording every function call. Enable it if you expect your application to crash, which may leave recording file truncated. It may degrade performance though.
### vmaAllocateMemory(VmaAllocator_T*,VkMemoryRequirements!System.Runtime.CompilerServices.IsConst*,VmaAllocationCreateInfo!System.Runtime.CompilerServices.IsConst*,VmaAllocation_T**,VmaAllocationInfo*)
\brief General purpose memory allocation. @param[out] pAllocation Handle to allocated memory. @param[out] pAllocationInfo Optional. Information about allocated memory. It can be later fetched using function vmaGetAllocationInfo(). You should free the memory using vmaFreeMemory() or vmaFreeMemoryPages(). It is recommended to use vmaAllocateMemoryForBuffer(), vmaAllocateMemoryForImage(), vmaCreateBuffer(), vmaCreateImage() instead whenever possible.
### vmaAllocateMemoryForBuffer(VmaAllocator_T*,VkBuffer_T*,VmaAllocationCreateInfo!System.Runtime.CompilerServices.IsConst*,VmaAllocation_T**,VmaAllocationInfo*)
@param[out] pAllocation Handle to allocated memory. @param[out] pAllocationInfo Optional. Information about allocated memory. It can be later fetched using function vmaGetAllocationInfo(). You should free the memory using vmaFreeMemory().
### vmaAllocateMemoryForImage(VmaAllocator_T*,VkImage_T*,VmaAllocationCreateInfo!System.Runtime.CompilerServices.IsConst*,VmaAllocation_T**,VmaAllocationInfo*)
Function similar to vmaAllocateMemoryForBuffer().
### vmaAllocateMemoryPages(VmaAllocator_T*,VkMemoryRequirements!System.Runtime.CompilerServices.IsConst*,VmaAllocationCreateInfo!System.Runtime.CompilerServices.IsConst*,System.UInt64,VmaAllocation_T**,VmaAllocationInfo*)
\brief General purpose memory allocation for multiple allocation objects at once. @param allocator Allocator object. @param pVkMemoryRequirements Memory requirements for each allocation. @param pCreateInfo Creation parameters for each alloction. @param allocationCount Number of allocations to make. @param[out] pAllocations Pointer to array that will be filled with handles to created allocations. @param[out] pAllocationInfo Optional. Pointer to array that will be filled with parameters of created allocations. You should free the memory using vmaFreeMemory() or vmaFreeMemoryPages(). Word "pages" is just a suggestion to use this function to allocate pieces of memory needed for sparse binding. It is just a general purpose allocation function able to make multiple allocations at once. It may be internally optimized to be more efficient than calling vmaAllocateMemory() `allocationCount` times. All allocations are made using same parameters. All of them are created out of the same memory pool and type. If any allocation fails, all allocations already made within this function call are also freed, so that when returned result is not `VK_SUCCESS`, `pAllocation` array is always entirely filled with `VK_NULL_HANDLE`.

## VmaAllocation_T
\struct VmaAllocation \brief Represents single memory allocation. It may be either dedicated block of `VkDeviceMemory` or a specific region of a bigger block of this type plus unique offset. There are multiple ways to create such object. You need to fill structure VmaAllocationCreateInfo. For more information see [Choosing memory type](@ref choosing_memory_type). Although the library provides convenience functions that create Vulkan buffer or image, allocate memory for it and bind them together, binding of the allocation to a buffer or an image is out of scope of the allocation itself. Allocation object can exist without buffer/image bound, binding can be done manually by the user, and destruction of it can be done independently of destruction of the allocation. The object also remembers its size and some other information. To retrieve this information, use function vmaGetAllocationInfo() and inspect returned structure VmaAllocationInfo. Some kinds allocations can be in lost state. For more information, see [Lost allocations](@ref lost_allocations).

## VmaAllocationCreateFlagBits
Flags to be passed as VmaAllocationCreateInfo::flags.
### VmaAllocationCreateInfo.flags
Use #VmaAllocationCreateFlagBits enum.
### VmaAllocationCreateInfo.memoryTypeBits
\brief Bitmask containing one bit set for every memory type acceptable for this allocation. Value 0 is equivalent to `UINT32_MAX` - it means any memory type is accepted if it meets other requirements specified by this structure, with no further restrictions on memory type index. \n If `pool` is not null, this member is ignored.
### VmaAllocationCreateInfo.pool
\brief Pool that this allocation should be created in. Leave `VK_NULL_HANDLE` to allocate from default pool. If not null, members: `usage`, `requiredFlags`, `preferredFlags`, `memoryTypeBits` are ignored.
### VmaAllocationCreateInfo.preferredFlags
\brief Flags that preferably should be set in a memory type chosen for an allocation. Set to 0 if no additional flags are prefered. \n If `pool` is not null, this member is ignored.
### VmaAllocationCreateInfo.pUserData
\brief Custom general-purpose pointer that will be stored in #VmaAllocation, can be read as VmaAllocationInfo::pUserData and changed using vmaSetAllocationUserData(). If #VMA_ALLOCATION_CREATE_USER_DATA_COPY_STRING_BIT is used, it must be either null or pointer to a null-terminated string. The string will be then copied to internal buffer, so it doesn't need to be valid after allocation call.
### VmaAllocationCreateInfo.requiredFlags
\brief Flags that must be set in a Memory Type chosen for an allocation. Leave 0 if you specify memory requirements in other way. \n If `pool` is not null, this member is ignored.
### VmaAllocationCreateInfo.usage
\brief Intended usage of memory. You can leave #VMA_MEMORY_USAGE_UNKNOWN if you specify memory requirements in other way. \n If `pool` is not null, this member is ignored.

## VmaAllocationInfo
\brief Parameters of #VmaAllocation objects, that can be retrieved using function vmaGetAllocationInfo().
### VmaAllocationInfo.deviceMemory
\brief Handle to Vulkan memory object. Same memory object can be shared by multiple allocations. It can change after call to vmaDefragment() if this allocation is passed to the function, or if allocation is lost. If the allocation is lost, it is equal to `VK_NULL_HANDLE`.
### VmaAllocationInfo.memoryType
\brief Memory type index that this allocation was allocated from. It never changes.
### VmaAllocationInfo.offset
\brief Offset into deviceMemory object to the beginning of this allocation, in bytes. (deviceMemory, offset) pair is unique to this allocation. It can change after call to vmaDefragment() if this allocation is passed to the function, or if allocation is lost.
### VmaAllocationInfo.pMappedData
\brief Pointer to the beginning of this allocation as mapped data. If the allocation hasn't been mapped using vmaMapMemory() and hasn't been created with #VMA_ALLOCATION_CREATE_MAPPED_BIT flag, this value null. It can change after call to vmaMapMemory(), vmaUnmapMemory(). It can also change after call to vmaDefragment() if this allocation is passed to the function.
### VmaAllocationInfo.pUserData
\brief Custom general-purpose pointer that was passed as VmaAllocationCreateInfo::pUserData or set using vmaSetAllocationUserData(). It can change after call to vmaSetAllocationUserData() for this allocation.
### VmaAllocationInfo.size
\brief Size of this allocation, in bytes. It never changes, unless allocation is lost.

## VmaAllocator_T
\struct VmaAllocator \brief Represents main object of this library initialized. Fill structure #VmaAllocatorCreateInfo and call function vmaCreateAllocator() to create it. Call function vmaDestroyAllocator() to destroy it. It is recommended to create just one object of this type per `VkDevice` object, right after Vulkan is initialized and keep it alive until before Vulkan device is destroyed.

## VmaAllocatorCreateFlagBits
Flags for created #VmaAllocator.

## VmaAllocatorCreateInfo
Description of a Allocator to be created.
### VmaAllocatorCreateInfo.device
Vulkan device. It must be valid throughout whole lifetime of created allocator.
### VmaAllocatorCreateInfo.flags
Flags for created allocator. Use #VmaAllocatorCreateFlagBits enum.
### VmaAllocatorCreateInfo.frameInUseCount
\brief Maximum number of additional frames that are in use at the same time as current frame. This value is used only when you make allocations with VMA_ALLOCATION_CREATE_CAN_BECOME_LOST_BIT flag. Such allocation cannot become lost if allocation.lastUseFrameIndex >= allocator.currentFrameIndex - frameInUseCount. For example, if you double-buffer your command buffers, so resources used for rendering in previous frame may still be in use by the GPU at the moment you allocate resources needed for the current frame, set this value to 1. If you want to allow any allocations other than used in the current frame to become lost, set this value to 0.
### VmaAllocatorCreateInfo.pAllocationCallbacks
Custom CPU memory allocation callbacks. Optional. Optional, can be null. When specified, will also be used for all CPU-side memory allocations.
### VmaAllocatorCreateInfo.pDeviceMemoryCallbacks
Informative callbacks for `vkAllocateMemory`, `vkFreeMemory`. Optional. Optional, can be null.
### VmaAllocatorCreateInfo.pHeapSizeLimit
\brief Either null or a pointer to an array of limits on maximum number of bytes that can be allocated out of particular Vulkan memory heap. If not NULL, it must be a pointer to an array of `VkPhysicalDeviceMemoryProperties::memoryHeapCount` elements, defining limit on maximum number of bytes that can be allocated out of particular Vulkan memory heap. Any of the elements may be equal to `VK_WHOLE_SIZE`, which means no limit on that heap. This is also the default in case of `pHeapSizeLimit` = NULL. If there is a limit defined for a heap: - If user tries to allocate more memory from that heap using this allocator, the allocation fails with `VK_ERROR_OUT_OF_DEVICE_MEMORY`. - If the limit is smaller than heap size reported in `VkMemoryHeap::size`, the value of this limit will be reported instead when using vmaGetMemoryProperties(). Warning! Using this feature may not be equivalent to installing a GPU with smaller amount of memory, because graphics driver doesn't necessary fail new allocations with `VK_ERROR_OUT_OF_DEVICE_MEMORY` result when memory capacity is exceeded. It may return success and just silently migrate some device memory blocks to system RAM. This driver behavior can also be controlled using VK_AMD_memory_overallocation_behavior extension.
### VmaAllocatorCreateInfo.physicalDevice
Vulkan physical device. It must be valid throughout whole lifetime of created allocator.
### VmaAllocatorCreateInfo.pRecordSettings
\brief Parameters for recording of VMA calls. Can be null. If not null, it enables recording of calls to VMA functions to a file. If support for recording is not enabled using `VMA_RECORDING_ENABLED` macro, creation of the allocator object fails with `VK_ERROR_FEATURE_NOT_PRESENT`.
### VmaAllocatorCreateInfo.preferredLargeHeapBlockSize
Preferred size of a single `VkDeviceMemory` block to be allocated from large heaps > 1 GiB. Optional. Set to 0 to use default, which is currently 256 MiB.
### vmaBindBufferMemory(VmaAllocator_T*,VmaAllocation_T*,VkBuffer_T*)
\brief Binds buffer to allocation. Binds specified buffer to region of memory represented by specified allocation. Gets `VkDeviceMemory` handle and offset from the allocation. If you want to create a buffer, allocate memory for it and bind them together separately, you should use this function for binding instead of standard `vkBindBufferMemory()`, because it ensures proper synchronization so that when a `VkDeviceMemory` object is used by multiple allocations, calls to `vkBind*Memory()` or `vkMapMemory()` won't happen from multiple threads simultaneously (which is illegal in Vulkan). It is recommended to use function vmaCreateBuffer() instead of this one.
### vmaBindImageMemory(VmaAllocator_T*,VmaAllocation_T*,VkImage_T*)
\brief Binds image to allocation. Binds specified image to region of memory represented by specified allocation. Gets `VkDeviceMemory` handle and offset from the allocation. If you want to create an image, allocate memory for it and bind them together separately, you should use this function for binding instead of standard `vkBindImageMemory()`, because it ensures proper synchronization so that when a `VkDeviceMemory` object is used by multiple allocations, calls to `vkBind*Memory()` or `vkMapMemory()` won't happen from multiple threads simultaneously (which is illegal in Vulkan). It is recommended to use function vmaCreateImage() instead of this one.
### vmaBuildStatsString(VmaAllocator_T*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte**,System.UInt32)
Builds and returns statistics as string in JSON format. @param[out] ppStatsString Must be freed using vmaFreeStatsString() function.
### vmaCalculateStats(VmaAllocator_T*,VmaStats*)
Retrieves statistics from current state of the Allocator.
### vmaCheckCorruption(VmaAllocator_T*,System.UInt32)
\brief Checks magic number in margins around all allocations in given memory types (in both default and custom pools) in search for corruptions. @param memoryTypeBits Bit mask, where each bit set means that a memory type with that index should be checked. Corruption detection is enabled only when `VMA_DEBUG_DETECT_CORRUPTION` macro is defined to nonzero, `VMA_DEBUG_MARGIN` is defined to nonzero and only for memory types that are `HOST_VISIBLE` and `HOST_COHERENT`. For more information, see [Corruption detection](@ref debugging_memory_usage_corruption_detection). Possible return values: - `VK_ERROR_FEATURE_NOT_PRESENT` - corruption detection is not enabled for any of specified memory types. - `VK_SUCCESS` - corruption detection has been performed and succeeded. - `VK_ERROR_VALIDATION_FAILED_EXT` - corruption detection has been performed and found memory corruptions around one of the allocations. `VMA_ASSERT` is also fired in that case. - Other value: Error returned by Vulkan, e.g. memory mapping failure.
### vmaCheckPoolCorruption(VmaAllocator_T*,VmaPool_T*)
\brief Checks magic number in margins around all allocations in given memory pool in search for corruptions. Corruption detection is enabled only when `VMA_DEBUG_DETECT_CORRUPTION` macro is defined to nonzero, `VMA_DEBUG_MARGIN` is defined to nonzero and the pool is created in memory type that is `HOST_VISIBLE` and `HOST_COHERENT`. For more information, see [Corruption detection](@ref debugging_memory_usage_corruption_detection). Possible return values: - `VK_ERROR_FEATURE_NOT_PRESENT` - corruption detection is not enabled for specified pool. - `VK_SUCCESS` - corruption detection has been performed and succeeded. - `VK_ERROR_VALIDATION_FAILED_EXT` - corruption detection has been performed and found memory corruptions around one of the allocations. `VMA_ASSERT` is also fired in that case. - Other value: Error returned by Vulkan, e.g. memory mapping failure.
### vmaCreateAllocator(VmaAllocatorCreateInfo!System.Runtime.CompilerServices.IsConst*,VmaAllocator_T**)
Creates Allocator object.
### vmaCreateBuffer(VmaAllocator_T*,VkBufferCreateInfo!System.Runtime.CompilerServices.IsConst*,VmaAllocationCreateInfo!System.Runtime.CompilerServices.IsConst*,VkBuffer_T**,VmaAllocation_T**,VmaAllocationInfo*)
@param[out] pBuffer Buffer that was created. @param[out] pAllocation Allocation that was created. @param[out] pAllocationInfo Optional. Information about allocated memory. It can be later fetched using function vmaGetAllocationInfo(). This function automatically: -# Creates buffer. -# Allocates appropriate memory for it. -# Binds the buffer with the memory. If any of these operations fail, buffer and allocation are not created, returned value is negative error code, *pBuffer and *pAllocation are null. If the function succeeded, you must destroy both buffer and allocation when you no longer need them using either convenience function vmaDestroyBuffer() or separately, using `vkDestroyBuffer()` and vmaFreeMemory(). If VMA_ALLOCATOR_CREATE_KHR_DEDICATED_ALLOCATION_BIT flag was used, VK_KHR_dedicated_allocation extension is used internally to query driver whether it requires or prefers the new buffer to have dedicated allocation. If yes, and if dedicated allocation is possible (VmaAllocationCreateInfo::pool is null and VMA_ALLOCATION_CREATE_NEVER_ALLOCATE_BIT is not used), it creates dedicated allocation for this buffer, just like when using VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT.
### vmaCreateImage(VmaAllocator_T*,VkImageCreateInfo!System.Runtime.CompilerServices.IsConst*,VmaAllocationCreateInfo!System.Runtime.CompilerServices.IsConst*,VkImage_T**,VmaAllocation_T**,VmaAllocationInfo*)
Function similar to vmaCreateBuffer().
### vmaCreateLostAllocation(VmaAllocator_T*,VmaAllocation_T**)
\brief Creates new allocation that is in lost state from the beginning. It can be useful if you need a dummy, non-null allocation. You still need to destroy created object using vmaFreeMemory(). Returned allocation is not tied to any specific memory pool or memory type and not bound to any image or buffer. It has size = 0. It cannot be turned into a real, non-empty allocation.
### vmaCreatePool(VmaAllocator_T*,VmaPoolCreateInfo!System.Runtime.CompilerServices.IsConst*,VmaPool_T**)
\brief Allocates Vulkan device memory and creates #VmaPool object. @param allocator Allocator object. @param pCreateInfo Parameters of pool to create. @param[out] pPool Handle to created pool.
### vmaDefragment(VmaAllocator_T*,VmaAllocation_T**,System.UInt64,System.UInt32*,VmaDefragmentationInfo!System.Runtime.CompilerServices.IsConst*,VmaDefragmentationStats*)
\brief Deprecated. Compacts memory by moving allocations. @param pAllocations Array of allocations that can be moved during this compation. @param allocationCount Number of elements in pAllocations and pAllocationsChanged arrays. @param[out] pAllocationsChanged Array of boolean values that will indicate whether matching allocation in pAllocations array has been moved. This parameter is optional. Pass null if you don't need this information. @param pDefragmentationInfo Configuration parameters. Optional - pass null to use default values. @param[out] pDefragmentationStats Statistics returned by the function. Optional - pass null if you don't need this information. @return `VK_SUCCESS` if completed, negative error code in case of error. \deprecated This is a part of the old interface. It is recommended to use structure #VmaDefragmentationInfo2 and function vmaDefragmentationBegin() instead. This function works by moving allocations to different places (different `VkDeviceMemory` objects and/or different offsets) in order to optimize memory usage. Only allocations that are in `pAllocations` array can be moved. All other allocations are considered nonmovable in this call. Basic rules: - Only allocations made in memory types that have `VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT` and `VK_MEMORY_PROPERTY_HOST_COHERENT_BIT` flags can be compacted. You may pass other allocations but it makes no sense - these will never be moved. - Custom pools created with #VMA_POOL_CREATE_LINEAR_ALGORITHM_BIT or #VMA_POOL_CREATE_BUDDY_ALGORITHM_BIT flag are not defragmented. Allocations passed to this function that come from such pools are ignored. - Allocations created with #VMA_ALLOCATION_CREATE_DEDICATED_MEMORY_BIT or created as dedicated allocations for any other reason are also ignored. - Both allocations made with or without #VMA_ALLOCATION_CREATE_MAPPED_BIT flag can be compacted. If not persistently mapped, memory will be mapped temporarily inside this function if needed. - You must not pass same #VmaAllocation object multiple times in `pAllocations` array. The function also frees empty `VkDeviceMemory` blocks. Warning: This function may be time-consuming, so you shouldn't call it too often (like after every resource creation/destruction). You can call it on special occasions (like when reloading a game level or when you just destroyed a lot of objects). Calling it every frame may be OK, but you should measure that on your platform. For more information, see [Defragmentation](@ref defragmentation) chapter.
### vmaDefragmentationBegin(VmaAllocator_T*,VmaDefragmentationInfo2!System.Runtime.CompilerServices.IsConst*,VmaDefragmentationStats*,VmaDefragmentationContext_T**)
\brief Begins defragmentation process. @param allocator Allocator object. @param pInfo Structure filled with parameters of defragmentation. @param[out] pStats Optional. Statistics of defragmentation. You can pass null if you are not interested in this information. @param[out] pContext Context object that must be passed to vmaDefragmentationEnd() to finish defragmentation. @return `VK_SUCCESS` and `*pContext == null` if defragmentation finished within this function call. `VK_NOT_READY` and `*pContext != null` if defragmentation has been started and you need to call vmaDefragmentationEnd() to finish it. Negative value in case of error. Use this function instead of old, deprecated vmaDefragment(). Warning! Between the call to vmaDefragmentationBegin() and vmaDefragmentationEnd(): - You should not use any of allocations passed as `pInfo->pAllocations` or any allocations that belong to pools passed as `pInfo->pPools`, including calling vmaGetAllocationInfo(), vmaTouchAllocation(), or access their data. - Some mutexes protecting internal data structures may be locked, so trying to make or free any allocations, bind buffers or images, map memory, or launch another simultaneous defragmentation in between may cause stall (when done on another thread) or deadlock (when done on the same thread), unless you are 100% sure that defragmented allocations are in different pools. - Information returned via `pStats` and `pInfo->pAllocationsChanged` are undefined. They become valid after call to vmaDefragmentationEnd(). - If `pInfo->commandBuffer` is not null, you must submit that command buffer and make sure it finished execution before calling vmaDefragmentationEnd(). For more information and important limitations regarding defragmentation, see documentation chapter: [Defragmentation](@ref defragmentation).

## VmaDefragmentationContext_T
\struct VmaDefragmentationContext \brief Represents Opaque object that represents started defragmentation process. Fill structure #VmaDefragmentationInfo2 and call function vmaDefragmentationBegin() to create it. Call function vmaDefragmentationEnd() to destroy it.
### vmaDefragmentationEnd(VmaAllocator_T*,VmaDefragmentationContext_T*)
\brief Ends defragmentation process. Use this function to finish defragmentation started by vmaDefragmentationBegin(). It is safe to pass `context == null`. The function then does nothing.

## VmaDefragmentationFlagBits
Flags to be used in vmaDefragmentationBegin(). None at the moment. Reserved for future use.

## VmaDefragmentationInfo
\brief Deprecated. Optional configuration parameters to be passed to function vmaDefragment(). \deprecated This is a part of the old interface. It is recommended to use structure #VmaDefragmentationInfo2 and function vmaDefragmentationBegin() instead.
### VmaDefragmentationInfo.maxAllocationsToMove
\brief Maximum number of allocations that can be moved to different place. Default is `UINT32_MAX`, which means no limit.
### VmaDefragmentationInfo.maxBytesToMove
\brief Maximum total numbers of bytes that can be copied while moving allocations to different places. Default is `VK_WHOLE_SIZE`, which means no limit.

## VmaDefragmentationInfo2
\brief Parameters for defragmentation. To be used with function vmaDefragmentationBegin().
### VmaDefragmentationInfo2.allocationCount
\brief Number of allocations in `pAllocations` array.
### VmaDefragmentationInfo2.commandBuffer
\brief Optional. Command buffer where GPU copy commands will be posted. If not null, it must be a valid command buffer handle that supports Transfer queue type. It must be in the recording state and outside of a render pass instance. You need to submit it and make sure it finished execution before calling vmaDefragmentationEnd(). Passing null means that only CPU defragmentation will be performed.
### VmaDefragmentationInfo2.flags
\brief Reserved for future use. Should be 0.
### VmaDefragmentationInfo2.maxCpuAllocationsToMove
\brief Maximum number of allocations that can be moved to a different place using transfers on CPU side, like `memcpy()`, `memmove()`. `UINT32_MAX` means no limit.
### VmaDefragmentationInfo2.maxCpuBytesToMove
\brief Maximum total numbers of bytes that can be copied while moving allocations to different places using transfers on CPU side, like `memcpy()`, `memmove()`. `VK_WHOLE_SIZE` means no limit.
### VmaDefragmentationInfo2.maxGpuAllocationsToMove
\brief Maximum number of allocations that can be moved to a different place using transfers on GPU side, posted to `commandBuffer`. `UINT32_MAX` means no limit.
### VmaDefragmentationInfo2.maxGpuBytesToMove
\brief Maximum total numbers of bytes that can be copied while moving allocations to different places using transfers on GPU side, posted to `commandBuffer`. `VK_WHOLE_SIZE` means no limit.
### VmaDefragmentationInfo2.pAllocations
\brief Pointer to array of allocations that can be defragmented. The array should have `allocationCount` elements. The array should not contain nulls. Elements in the array should be unique - same allocation cannot occur twice. It is safe to pass allocations that are in the lost state - they are ignored. All allocations not present in this array are considered non-moveable during this defragmentation.
### VmaDefragmentationInfo2.pAllocationsChanged
\brief Optional, output. Pointer to array that will be filled with information whether the allocation at certain index has been changed during defragmentation. The array should have `allocationCount` elements. You can pass null if you are not interested in this information.
### VmaDefragmentationInfo2.poolCount
\brief Numer of pools in `pPools` array.
### VmaDefragmentationInfo2.pPools
\brief Either null or pointer to array of pools to be defragmented. All the allocations in the specified pools can be moved during defragmentation and there is no way to check if they were really moved as in `pAllocationsChanged`, so you must query all the allocations in all these pools for new `VkDeviceMemory` and offset using vmaGetAllocationInfo() if you might need to recreate buffers and images bound to them. The array should have `poolCount` elements. The array should not contain nulls. Elements in the array should be unique - same pool cannot occur twice. Using this array is equivalent to specifying all allocations from the pools in `pAllocations`. It might be more efficient.

## VmaDefragmentationStats
\brief Statistics returned by function vmaDefragment().
### VmaDefragmentationStats.allocationsMoved
Number of allocations that have been moved to different places.
### VmaDefragmentationStats.bytesFreed
Total number of bytes that have been released to the system by freeing empty `VkDeviceMemory` objects.
### VmaDefragmentationStats.bytesMoved
Total number of bytes that have been copied while moving allocations to different places.
### VmaDefragmentationStats.deviceMemoryBlocksFreed
Number of empty `VkDeviceMemory` objects that have been released to the system.
### vmaDestroyAllocator(VmaAllocator_T*)
Destroys allocator object.
### vmaDestroyBuffer(VmaAllocator_T*,VkBuffer_T*,VmaAllocation_T*)
\brief Destroys Vulkan buffer and frees allocated memory. This is just a convenience function equivalent to: \code vkDestroyBuffer(device, buffer, allocationCallbacks); vmaFreeMemory(allocator, allocation); \endcode It it safe to pass null as buffer and/or allocation.
### vmaDestroyImage(VmaAllocator_T*,VkImage_T*,VmaAllocation_T*)
\brief Destroys Vulkan image and frees allocated memory. This is just a convenience function equivalent to: \code vkDestroyImage(device, image, allocationCallbacks); vmaFreeMemory(allocator, allocation); \endcode It it safe to pass null as image and/or allocation.
### vmaDestroyPool(VmaAllocator_T*,VmaPool_T*)
\brief Destroys #VmaPool object and frees Vulkan device memory.

## VmaDeviceMemoryCallbacks
\brief Set of callbacks that the library will call for `vkAllocateMemory` and `vkFreeMemory`. Provided for informative purpose, e.g. to gather statistics about number of allocations or total amount of memory allocated in Vulkan. Used in VmaAllocatorCreateInfo::pDeviceMemoryCallbacks.
### VmaDeviceMemoryCallbacks.pfnAllocate
Optional, can be null.
### VmaDeviceMemoryCallbacks.pfnFree
Optional, can be null.
### vmaFindMemoryTypeIndex(VmaAllocator_T*,System.UInt32,VmaAllocationCreateInfo!System.Runtime.CompilerServices.IsConst*,System.UInt32*)
\brief Helps to find memoryTypeIndex, given memoryTypeBits and VmaAllocationCreateInfo. This algorithm tries to find a memory type that: - Is allowed by memoryTypeBits. - Contains all the flags from pAllocationCreateInfo->requiredFlags. - Matches intended usage. - Has as many flags from pAllocationCreateInfo->preferredFlags as possible. \return Returns VK_ERROR_FEATURE_NOT_PRESENT if not found. Receiving such result from this function or any other allocating function probably means that your device doesn't support any memory type with requested features for the specific type of resource you want to use it for. Please check parameters of your resource, like image layout (OPTIMAL versus LINEAR) or mip level count.
### vmaFindMemoryTypeIndexForBufferInfo(VmaAllocator_T*,VkBufferCreateInfo!System.Runtime.CompilerServices.IsConst*,VmaAllocationCreateInfo!System.Runtime.CompilerServices.IsConst*,System.UInt32*)
\brief Helps to find memoryTypeIndex, given VkBufferCreateInfo and VmaAllocationCreateInfo. It can be useful e.g. to determine value to be used as VmaPoolCreateInfo::memoryTypeIndex. It internally creates a temporary, dummy buffer that never has memory bound. It is just a convenience function, equivalent to calling: - `vkCreateBuffer` - `vkGetBufferMemoryRequirements` - `vmaFindMemoryTypeIndex` - `vkDestroyBuffer`
### vmaFindMemoryTypeIndexForImageInfo(VmaAllocator_T*,VkImageCreateInfo!System.Runtime.CompilerServices.IsConst*,VmaAllocationCreateInfo!System.Runtime.CompilerServices.IsConst*,System.UInt32*)
\brief Helps to find memoryTypeIndex, given VkImageCreateInfo and VmaAllocationCreateInfo. It can be useful e.g. to determine value to be used as VmaPoolCreateInfo::memoryTypeIndex. It internally creates a temporary, dummy image that never has memory bound. It is just a convenience function, equivalent to calling: - `vkCreateImage` - `vkGetImageMemoryRequirements` - `vmaFindMemoryTypeIndex` - `vkDestroyImage`
### vmaFlushAllocation(VmaAllocator_T*,VmaAllocation_T*,System.UInt64,System.UInt64)
\brief Flushes memory of given allocation. Calls `vkFlushMappedMemoryRanges()` for memory associated with given range of given allocation. - `offset` must be relative to the beginning of allocation. - `size` can be `VK_WHOLE_SIZE`. It means all memory from `offset` the the end of given allocation. - `offset` and `size` don't have to be aligned. They are internally rounded down/up to multiply of `nonCoherentAtomSize`. - If `size` is 0, this call is ignored. - If memory type that the `allocation` belongs to is not `HOST_VISIBLE` or it is `HOST_COHERENT`, this call is ignored. Warning! `offset` and `size` are relative to the contents of given `allocation`. If you mean whole allocation, you can pass 0 and `VK_WHOLE_SIZE`, respectively. Do not pass allocation's offset as `offset`!!!
### vmaFreeMemory(VmaAllocator_T*,VmaAllocation_T*)
\brief Frees memory previously allocated using vmaAllocateMemory(), vmaAllocateMemoryForBuffer(), or vmaAllocateMemoryForImage(). Passing `VK_NULL_HANDLE` as `allocation` is valid. Such function call is just skipped.
### vmaFreeMemoryPages(VmaAllocator_T*,System.UInt64,VmaAllocation_T**)
\brief Frees memory and destroys multiple allocations. Word "pages" is just a suggestion to use this function to free pieces of memory used for sparse binding. It is just a general purpose function to free memory and destroy allocations made using e.g. vmaAllocateMemory(), vmaAllocateMemoryPages() and other functions. It may be internally optimized to be more efficient than calling vmaFreeMemory() `allocationCount` times. Allocations in `pAllocations` array can come from any memory pools and types. Passing `VK_NULL_HANDLE` as elements of `pAllocations` array is valid. Such entries are just skipped.
### vmaGetAllocationInfo(VmaAllocator_T*,VmaAllocation_T*,VmaAllocationInfo*)
\brief Returns current information about specified allocation and atomically marks it as used in current frame. Current paramters of given allocation are returned in `pAllocationInfo`. This function also atomically "touches" allocation - marks it as used in current frame, just like vmaTouchAllocation(). If the allocation is in lost state, `pAllocationInfo->deviceMemory == VK_NULL_HANDLE`. Although this function uses atomics and doesn't lock any mutex, so it should be quite efficient, you can avoid calling it too often. - You can retrieve same VmaAllocationInfo structure while creating your resource, from function vmaCreateBuffer(), vmaCreateImage(). You can remember it if you are sure parameters don't change (e.g. due to defragmentation or allocation becoming lost). - If you just want to check if allocation is not lost, vmaTouchAllocation() will work faster.
### vmaGetMemoryProperties(VmaAllocator_T*,VkPhysicalDeviceMemoryProperties!System.Runtime.CompilerServices.IsConst**)
PhysicalDeviceMemoryProperties are fetched from physicalDevice by the allocator. You can access it here, without fetching it again on your own.
### vmaGetMemoryTypeProperties(VmaAllocator_T*,System.UInt32,System.UInt32*)
\brief Given Memory Type Index, returns Property Flags of this memory type. This is just a convenience function. Same information can be obtained using vmaGetMemoryProperties().
### vmaGetPhysicalDeviceProperties(VmaAllocator_T*,VkPhysicalDeviceProperties!System.Runtime.CompilerServices.IsConst**)
PhysicalDeviceProperties are fetched from physicalDevice by the allocator. You can access it here, without fetching it again on your own.
### vmaGetPoolStats(VmaAllocator_T*,VmaPool_T*,VmaPoolStats*)
\brief Retrieves statistics of existing #VmaPool object. @param allocator Allocator object. @param pool Pool object. @param[out] pPoolStats Statistics of specified pool.
### vmaInvalidateAllocation(VmaAllocator_T*,VmaAllocation_T*,System.UInt64,System.UInt64)
\brief Invalidates memory of given allocation. Calls `vkInvalidateMappedMemoryRanges()` for memory associated with given range of given allocation. - `offset` must be relative to the beginning of allocation. - `size` can be `VK_WHOLE_SIZE`. It means all memory from `offset` the the end of given allocation. - `offset` and `size` don't have to be aligned. They are internally rounded down/up to multiply of `nonCoherentAtomSize`. - If `size` is 0, this call is ignored. - If memory type that the `allocation` belongs to is not `HOST_VISIBLE` or it is `HOST_COHERENT`, this call is ignored. Warning! `offset` and `size` are relative to the contents of given `allocation`. If you mean whole allocation, you can pass 0 and `VK_WHOLE_SIZE`, respectively. Do not pass allocation's offset as `offset`!!!
### vmaMakePoolAllocationsLost(VmaAllocator_T*,VmaPool_T*,System.UInt64*)
\brief Marks all allocations in given pool as lost if they are not used in current frame or VmaPoolCreateInfo::frameInUseCount back from now. @param allocator Allocator object. @param pool Pool. @param[out] pLostAllocationCount Number of allocations marked as lost. Optional - pass null if you don't need this information.
### vmaMapMemory(VmaAllocator_T*,VmaAllocation_T*,System.Void**)
\brief Maps memory represented by given allocation and returns pointer to it. Maps memory represented by given allocation to make it accessible to CPU code. When succeeded, `*ppData` contains pointer to first byte of this memory. If the allocation is part of bigger `VkDeviceMemory` block, the pointer is correctly offseted to the beginning of region assigned to this particular allocation. Mapping is internally reference-counted and synchronized, so despite raw Vulkan function `vkMapMemory()` cannot be used to map same block of `VkDeviceMemory` multiple times simultaneously, it is safe to call this function on allocations assigned to the same memory block. Actual Vulkan memory will be mapped on first mapping and unmapped on last unmapping. If the function succeeded, you must call vmaUnmapMemory() to unmap the allocation when mapping is no longer needed or before freeing the allocation, at the latest. It also safe to call this function multiple times on the same allocation. You must call vmaUnmapMemory() same number of times as you called vmaMapMemory(). It is also safe to call this function on allocation created with #VMA_ALLOCATION_CREATE_MAPPED_BIT flag. Its memory stays mapped all the time. You must still call vmaUnmapMemory() same number of times as you called vmaMapMemory(). You must not call vmaUnmapMemory() additional time to free the "0-th" mapping made automatically due to #VMA_ALLOCATION_CREATE_MAPPED_BIT flag. This function fails when used on allocation made in memory type that is not `HOST_VISIBLE`. This function always fails when called for allocation that was created with #VMA_ALLOCATION_CREATE_CAN_BECOME_LOST_BIT flag. Such allocations cannot be mapped.

## VmaPool_T
\struct VmaPool \brief Represents custom memory pool Fill structure VmaPoolCreateInfo and call function vmaCreatePool() to create it. Call function vmaDestroyPool() to destroy it. For more information see [Custom memory pools](@ref choosing_memory_type_custom_memory_pools).

## VmaPoolCreateFlagBits
Flags to be passed as VmaPoolCreateInfo::flags.

## VmaPoolCreateInfo
\brief Describes parameter of created #VmaPool.
### VmaPoolCreateInfo.blockSize
\brief Size of a single `VkDeviceMemory` block to be allocated as part of this pool, in bytes. Optional. Specify nonzero to set explicit, constant size of memory blocks used by this pool. Leave 0 to use default and let the library manage block sizes automatically. Sizes of particular blocks may vary.
### VmaPoolCreateInfo.flags
\brief Use combination of #VmaPoolCreateFlagBits.
### VmaPoolCreateInfo.frameInUseCount
\brief Maximum number of additional frames that are in use at the same time as current frame. This value is used only when you make allocations with #VMA_ALLOCATION_CREATE_CAN_BECOME_LOST_BIT flag. Such allocation cannot become lost if allocation.lastUseFrameIndex >= allocator.currentFrameIndex - frameInUseCount. For example, if you double-buffer your command buffers, so resources used for rendering in previous frame may still be in use by the GPU at the moment you allocate resources needed for the current frame, set this value to 1. If you want to allow any allocations other than used in the current frame to become lost, set this value to 0.
### VmaPoolCreateInfo.maxBlockCount
\brief Maximum number of blocks that can be allocated in this pool. Optional. Set to 0 to use default, which is `SIZE_MAX`, which means no limit. Set to same value as VmaPoolCreateInfo::minBlockCount to have fixed amount of memory allocated throughout whole lifetime of this pool.
### VmaPoolCreateInfo.memoryTypeIndex
\brief Vulkan memory type index to allocate this pool from.
### VmaPoolCreateInfo.minBlockCount
\brief Minimum number of blocks to be always allocated in this pool, even if they stay empty. Set to 0 to have no preallocated blocks and allow the pool be completely empty.

## VmaPoolStats
\brief Describes parameter of existing #VmaPool.
### VmaPoolStats.allocationCount
\brief Number of #VmaAllocation objects created from this pool that were not destroyed or lost.
### VmaPoolStats.blockCount
\brief Number of `VkDeviceMemory` blocks allocated for this pool.
### VmaPoolStats.size
\brief Total amount of `VkDeviceMemory` allocated from Vulkan for this pool, in bytes.
### VmaPoolStats.unusedRangeCount
\brief Number of continuous memory ranges in the pool not used by any #VmaAllocation.
### VmaPoolStats.unusedRangeSizeMax
\brief Size of the largest continuous free memory region available for new allocation. Making a new allocation of that size is not guaranteed to succeed because of possible additional margin required to respect alignment and buffer/image granularity.
### VmaPoolStats.unusedSize
\brief Total number of bytes in the pool not used by any #VmaAllocation.

## VmaRecordFlagBits
Flags to be used in VmaRecordSettings::flags.

## VmaRecordSettings
Parameters for recording calls to VMA functions. To be used in VmaAllocatorCreateInfo::pRecordSettings.
### VmaRecordSettings.flags
Flags for recording. Use #VmaRecordFlagBits enum.
### VmaRecordSettings.pFilePath
\brief Path to the file that should be written by the recording. Suggested extension: "csv". If the file already exists, it will be overwritten. It will be opened for the whole time #VmaAllocator object is alive. If opening this file fails, creation of the whole allocator object fails.
### vmaResizeAllocation(VmaAllocator_T*,VmaAllocation_T*,System.UInt64)
\brief Tries to resize an allocation in place, if there is enough free memory after it. Tries to change allocation's size without moving or reallocating it. You can both shrink and grow allocation size. When growing, it succeeds only when the allocation belongs to a memory block with enough free space after it. Returns `VK_SUCCESS` if allocation's size has been successfully changed. Returns `VK_ERROR_OUT_OF_POOL_MEMORY` if allocation's size could not be changed. After successful call to this function, VmaAllocationInfo::size of this allocation changes. All other parameters stay the same: memory pool and type, alignment, offset, mapped pointer. - Calling this function on allocation that is in lost state fails with result `VK_ERROR_VALIDATION_FAILED_EXT`. - Calling this function with `newSize` same as current allocation size does nothing and returns `VK_SUCCESS`. - Resizing dedicated allocations, as well as allocations created in pools that use linear or buddy algorithm, is not supported. The function returns `VK_ERROR_FEATURE_NOT_PRESENT` in such cases. Support may be added in the future.
### vmaSetAllocationUserData(VmaAllocator_T*,VmaAllocation_T*,System.Void*)
\brief Sets pUserData in given allocation to new value. If the allocation was created with VMA_ALLOCATION_CREATE_USER_DATA_COPY_STRING_BIT, pUserData must be either null, or pointer to a null-terminated string. The function makes local copy of the string and sets it as allocation's `pUserData`. String passed as pUserData doesn't need to be valid for whole lifetime of the allocation - you can free it after this call. String previously pointed by allocation's pUserData is freed from memory. If the flag was not used, the value of pointer `pUserData` is just copied to allocation's `pUserData`. It is opaque, so you can use it however you want - e.g. as a pointer, ordinal number or some handle to you own data.
### vmaSetCurrentFrameIndex(VmaAllocator_T*,System.UInt32)
\brief Sets index of the current frame. This function must be used if you make allocations with #VMA_ALLOCATION_CREATE_CAN_BECOME_LOST_BIT and #VMA_ALLOCATION_CREATE_CAN_MAKE_OTHER_LOST_BIT flags to inform the allocator when a new frame begins. Allocations queried using vmaGetAllocationInfo() cannot become lost in the current frame.

## VmaStatInfo
\brief Calculated statistics of memory usage in entire allocator.
### VmaStatInfo.allocationCount
Number of #VmaAllocation allocation objects allocated.
### VmaStatInfo.blockCount
Number of `VkDeviceMemory` Vulkan memory blocks allocated.
### VmaStatInfo.unusedBytes
Total number of bytes occupied by unused ranges.
### VmaStatInfo.unusedRangeCount
Number of free ranges of memory between allocations.
### VmaStatInfo.usedBytes
Total number of bytes occupied by all allocations.

## VmaStats
General statistics from current state of Allocator.
### vmaTouchAllocation(VmaAllocator_T*,VmaAllocation_T*)
\brief Returns `VK_TRUE` if allocation is not lost and atomically marks it as used in current frame. If the allocation has been created with #VMA_ALLOCATION_CREATE_CAN_BECOME_LOST_BIT flag, this function returns `VK_TRUE` if it's not in lost state, so it can still be used. It then also atomically "touches" the allocation - marks it as used in current frame, so that you can be sure it won't become lost in current frame or next `frameInUseCount` frames. If the allocation is in lost state, the function returns `VK_FALSE`. Memory of such allocation, as well as buffer or image bound to it, should not be used. Lost allocation and the buffer/image still need to be destroyed. If the allocation has been created without #VMA_ALLOCATION_CREATE_CAN_BECOME_LOST_BIT flag, this function always returns `VK_TRUE`.
### vmaUnmapMemory(VmaAllocator_T*,VmaAllocation_T*)
\brief Unmaps memory represented by given allocation, mapped previously using vmaMapMemory(). For details, see description of vmaMapMemory().

## VmaVulkanFunctions
\brief Pointers to some Vulkan functions - a subset used by the library. Used in VmaAllocatorCreateInfo::pVulkanFunctions.
### vr.BoneIndex_t
Type used for referring to bones by their index

## Compositor_CumulativeStats
Cumulative stats for current application. These are not cleared until a new app connects, * but they do stop accumulating once the associated app disconnects.
### m_nNumFramePresentsOnStartup
Values recorded at startup before application has fully faded in the first time.
### m_nNumLoading
Applications may explicitly fade to the compositor. This is usually to handle level transitions, and loading often causes * system wide hitches. The following stats are collected during this period. Does not include values recorded during startup.
### m_nNumTimedOut
If we don't get a new frame from the app in less than 2.5 frames, then we assume the app has hung and start * fading back to the compositor. The following stats are a result of this, and are a subset of those recorded above. * Does not include values recorded during start up or loading.

## Compositor_FrameTiming
Provides a single frame's timing information to the app
### m_flClientFrameIntervalMs
Miscellaneous measured intervals.
### m_flPreSubmitGpuMs
These times may include work from other processes due to OS scheduling. * The fewer packets of work these are broken up into, the less likely this will happen. * GPU work can be broken up by calling Flush. This can sometimes be useful to get the GPU started * processing that work earlier in the frame.
### m_flSystemTimeInSeconds
Absolute time reference for comparing frames. This aligns with the vsync that running start is relative to.
### m_flWaitGetPosesCalledMs
The following are all relative to this frame's SystemTimeInSeconds

## Compositor_OverlaySettings
Allows the application to customize how the overlay appears in the compositor

## D3D12TextureData_t
Data required for passing D3D12 textures to IVRCompositor::Submit. * Be sure to call OpenVR_Shutdown before destroying these resources.

## DistortionCoordinates_t
Used to return the post-distortion UVs for each color channel. * UVs range from 0 to 1 with 0,0 in the upper left corner of the * source render target. The 0,0 to 1,1 range covers a single eye.

## DriverDirectMode_FrameTiming
Frame timing data provided by direct mode drivers.

## ECollisionBoundsStyle
Collision Bounds Style

## EDeviceActivityLevel
Level of Hmd activity

## EHmdTrackingStyle
Used to drive certain text in the UI when talking about the tracking system for the HMD

## EOverlayDirection
Directions for changing focus between overlays with the gamepad

## ETrackedControllerRole
Describes what specific role associated with a tracked device

## ETrackedDeviceClass
Describes what kind of object is being tracked at a given ID

## ETrackedDeviceProperty
Each entry in this enum represents a property that can be retrieved about a * tracked device. Many fields are only valid for one ETrackedDeviceClass.

## ETrackedPropertyError
Used to return errors that occur when reading properties.

## ETrackingUniverseOrigin
Identifies which style of tracking origin the application wants to use * for the poses it is requesting

## EVRApplicationError
Used for all errors reported by the IVRApplications interface

## EVRApplicationProperty
these are the properties available on applications.

## EVRApplicationTransitionState
These are states the scene application startup process will go through.

## EVRApplicationType
enum values to pass in to VR_Init to identify whether the application will * draw a 3D scene.

## EVRButtonId
VR controller button and axis IDs

## EVRCompositorError
Errors that can occur with the VR compositor

## EVRCompositorTimingMode
Timing mode passed to SetExplicitTimingMode(); see that function for documentation

## EVRControllerAxisType
Identifies what kind of axis is on the controller at index n. Read this type * with pVRSystem->Get( nControllerDeviceIndex, Prop_Axis0Type_Int32 + n );

## EVRControllerEventOutputType
determines how to provide output to the application of various event processing functions.

## EVREventType
The types of events that could be posted (and what the parameters mean for each event type)

## EVRFirmwareError
error codes for firmware

## EVRInitError
error codes returned by Vr_Init

## EVRMouseButton
used for simulated mouse events in overlay space

## EVRNotificationError
error codes for notifications

## EVRNotificationType
Be aware that the notification type is used as 'priority' to pick the next notification

## EVROverlayError
Errors that can occur around VR overlays

## EVRRenderModelError
Errors that can occur with the VR compositor

## EVRScreenshotError
Errors that can occur with the VR compositor

## EVRState
Status of the overall system or tracked objects

## EVRSubmitFlags
Allows the application to control how scene textures are used by the compositor when calling Submit.

## HiddenAreaMesh_t
The mesh to draw into the stencil (or depth) buffer to perform * early stencil (or depth) kills of pixels that will never appear on the HMD. * This mesh draws on all the pixels that will be hidden after distortion. * * If the HMD does not provide a visible area mesh pVertexData will be * NULL and unTriangleCount will be 0.

## Imu_OffScaleFlags
raw IMU data provided by IVRIOBuffer from paths to tracked devices with IMUs
### vr.InputAnalogActionData_t.activeOrigin
The origin that caused this action's current state
### vr.InputAnalogActionData_t.bActive
Whether or not this action is currently available to be bound in the active action set
### vr.InputAnalogActionData_t.deltaX
Deltas since the previous call to UpdateActionState()
### vr.InputAnalogActionData_t.fUpdateTime
Time relative to now when this event happened. Will be negative to indicate a past time.
### vr.InputAnalogActionData_t.x
The current state of this action; will be delta updates for mouse actions
### vr.InputDigitalActionData_t.activeOrigin
The origin that caused this action's current state
### vr.InputDigitalActionData_t.bActive
Whether or not this action is currently available to be bound in the active action set
### vr.InputDigitalActionData_t.bChanged
This is true if the state has changed since the last frame
### vr.InputDigitalActionData_t.bState
The current state of this action; will be true if currently pressed
### vr.InputDigitalActionData_t.fUpdateTime
Time relative to now when this event happened. Will be negative to indicate a past time.
### vr.InputPoseActionData_t.activeOrigin
The origin that caused this action's current state
### vr.InputPoseActionData_t.bActive
Whether or not this action is currently available to be bound in the active action set
### vr.InputPoseActionData_t.pose
The current state of this action
### vr.InputSkeletalActionData_t.activeOrigin
The origin that caused this action's current state
### vr.InputSkeletalActionData_t.bActive
Whether or not this action is currently available to be bound in the active action set
### vr.IsRoleAllowedAsHand(vr.ETrackedControllerRole)
Returns true if the tracked controller role is allowed to be a hand
### vr.IVRApplications.AddApplicationManifest(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Boolean)
Adds an application manifest to the list to load when building the list of installed applications. * Temporary manifests are not automatically loaded
### vr.IVRApplications.CancelApplicationLaunch(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)
Cancel a pending launch for an application
### vr.IVRApplications.GetApplicationAutoLaunch(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)
Gets the application auto-launch flag. This is only valid for applications which return true for VRApplicationProperty_IsDashboardOverlay_Bool.
### vr.IVRApplications.GetApplicationCount
Returns the number of applications available in the list
### vr.IVRApplications.GetApplicationKeyByIndex(System.UInt32,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,System.UInt32)
Returns the key of the specified application. The index is at least 0 and is less than the return * value of GetApplicationCount(). The buffer should be at least k_unMaxApplicationKeyLength in order to * fit the key.
### vr.IVRApplications.GetApplicationKeyByProcessId(System.UInt32,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,System.UInt32)
Returns the key of the application for the specified Process Id. The buffer should be at least * k_unMaxApplicationKeyLength in order to fit the key.
### vr.IVRApplications.GetApplicationLaunchArguments(System.UInt32,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,System.UInt32)
Get the args list from an app launch that had the process already running, you call this when you get a VREvent_ApplicationMimeTypeLoad
### vr.IVRApplications.GetApplicationProcessId(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)
Returns the process ID for an application. Return 0 if the application was not found or is not running.
### vr.IVRApplications.GetApplicationPropertyBool(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,vr.EVRApplicationProperty,vr.EVRApplicationError*)
Returns a bool value for an application property. Returns false in all error cases.
### vr.IVRApplications.GetApplicationPropertyString(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,vr.EVRApplicationProperty,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,System.UInt32,vr.EVRApplicationError*)
Returns a value for an application property. The required buffer size to fit this value will be returned.
### vr.IVRApplications.GetApplicationPropertyUint64(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,vr.EVRApplicationProperty,vr.EVRApplicationError*)
Returns a uint64 value for an application property. Returns 0 in all error cases.
### vr.IVRApplications.GetApplicationsErrorNameFromEnum(vr.EVRApplicationError)
Returns a string for an applications error
### vr.IVRApplications.GetApplicationsThatSupportMimeType(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,System.UInt32)
Get the list of app-keys that support this mime type, comma-delimited, the return value is number of bytes you need to return the full string
### vr.IVRApplications.GetApplicationsTransitionStateNameFromEnum(vr.EVRApplicationTransitionState)
Returns a string for an application transition state
### vr.IVRApplications.GetApplicationSupportedMimeTypes(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,System.UInt32)
Get the list of supported mime types for this application, comma-delimited
### vr.IVRApplications.GetCurrentSceneProcessId
Returns the current scene process ID according to the application system. A scene process will get scene * focus once it starts rendering, but it will appear here once it calls VR_Init with the Scene application * type.
### vr.IVRApplications.GetDefaultApplicationForMimeType(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,System.UInt32)
return the app key that will open this mime type
### vr.IVRApplications.GetStartingApplication(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,System.UInt32)
Returns the app key for the application that is starting up
### vr.IVRApplications.GetTransitionState
Returns the application transition state
### vr.IVRApplications.IdentifyApplication(System.UInt32,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)
Identifies a running application. OpenVR can't always tell which process started in response * to a URL. This function allows a URL handler (or the process itself) to identify the app key * for the now running application. Passing a process ID of 0 identifies the calling process. * The application must be one that's known to the system via a call to AddApplicationManifest.
### vr.IVRApplications.IsApplicationInstalled(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)
Returns true if an application is installed
### vr.IVRApplications.IsQuitUserPromptRequested
Returns true if the outgoing scene app has requested a save prompt before exiting
### vr.IVRApplications.LaunchApplication(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)
Launches the application. The existing scene application will exit and then the new application will start. * This call is not valid for dashboard overlay applications.
### vr.IVRApplications.LaunchApplicationFromMimeType(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)
launches the application currently associated with this mime type and passes it the option args, typically the filename or object name of the item being launched
### vr.IVRApplications.LaunchDashboardOverlay(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)
Launches the dashboard overlay application if it is not already running. This call is only valid for * dashboard overlay applications.
### vr.IVRApplications.LaunchInternalProcess(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)
Starts a subprocess within the calling application. This * suppresses all application transition UI and automatically identifies the new executable * as part of the same application. On success the calling process should exit immediately. * If working directory is NULL or "" the directory portion of the binary path will be * the working directory.
### vr.IVRApplications.LaunchTemplateApplication(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,vr.AppOverrideKeys_t!System.Runtime.CompilerServices.IsConst*,System.UInt32)
Launches an instance of an application of type template, with its app key being pchNewAppKey (which must be unique) and optionally override sections * from the manifest file via AppOverrideKeys_t
### vr.IVRApplications.PerformApplicationPrelaunchCheck(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)
Returns errors that would prevent the specified application from launching immediately. Calling this function will * cause the current scene application to quit, so only call it when you are actually about to launch something else. * What the caller should do about these failures depends on the failure: * VRApplicationError_OldApplicationQuitting - An existing application has been told to quit. Wait for a VREvent_ProcessQuit * and try again. * VRApplicationError_ApplicationAlreadyStarting - This application is already starting. This is a permanent failure. * VRApplicationError_LaunchInProgress - A different application is already starting. This is a permanent failure. * VRApplicationError_None - Go ahead and launch. Everything is clear.
### vr.IVRApplications.RemoveApplicationManifest(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)
Removes an application manifest from the list to load when building the list of installed applications.
### vr.IVRApplications.SetApplicationAutoLaunch(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Boolean)
Sets the application auto-launch flag. This is only valid for applications which return true for VRApplicationProperty_IsDashboardOverlay_Bool.
### vr.IVRApplications.SetDefaultApplicationForMimeType(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)
Adds this mime-type to the list of supported mime types for this application

## IVRChaperone
HIGH LEVEL TRACKING SPACE ASSUMPTIONS: * 0,0,0 is the preferred standing area center. * 0Y is the floor height. * -Z is the preferred forward facing direction.
### AreBoundsVisible
Determine whether the bounds are showing right now *
### ForceBoundsVisible(System.Boolean)
Force the bounds to show, mostly for utilities *
### GetBoundsColor(vr.HmdColor_t*,System.Int32,System.Single,vr.HmdColor_t*)
Get the current chaperone bounds draw color and brightness *
### GetCalibrationState
Get the current state of Chaperone calibration. This state can change at any time during a session due to physical base station changes. *
### GetPlayAreaRect(vr.HmdQuad_t*)
Returns the 4 corner positions of the Play Area (formerly named Soft Bounds). * Corners are in counter-clockwise order. * Standing center (0,0,0) is the center of the Play Area. * It's a rectangle. * 2 sides are parallel to the X axis and 2 sides are parallel to the Z axis. * Height of every corner is 0Y (on the floor). *
### GetPlayAreaSize(System.Single*,System.Single*)
Returns the width and depth of the Play Area (formerly named Soft Bounds) in X and Z. * Tracking space center (0,0,0) is the center of the Play Area. *
### ReloadInfo
Reload Chaperone data from the .vrchap file on disk.
### SetSceneColor(vr.HmdColor_t)
Optionally give the chaperone system a hit about the color and brightness in the scene *

## IVRChaperoneSetup
Manages the working copy of the chaperone info. By default this will be the same as the * live copy. Any changes made with this interface will stay in the working copy until * CommitWorkingCopy() is called, at which point the working copy and the live copy will be * the same again.
### CommitWorkingCopy(vr.EChaperoneConfigFile)
Saves the current working copy to disk
### GetLiveCollisionBoundsInfo(vr.HmdQuad_t*,System.UInt32*)
Returns the number of Quads if the buffer points to null. Otherwise it returns Quads * into the buffer up to the max specified.
### GetLiveSeatedZeroPoseToRawTrackingPose(vr.HmdMatrix34_t*)
Returns the preferred seated position.
### GetWorkingCollisionBoundsInfo(vr.HmdQuad_t*,System.UInt32*)
Returns the number of Quads if the buffer points to null. Otherwise it returns Quads * into the buffer up to the max specified from the working copy.
### GetWorkingPlayAreaRect(vr.HmdQuad_t*)
Returns the 4 corner positions of the Play Area (formerly named Soft Bounds) from the working copy. * Corners are in clockwise order. * Tracking space center (0,0,0) is the center of the Play Area. * It's a rectangle. * 2 sides are parallel to the X axis and 2 sides are parallel to the Z axis. * Height of every corner is 0Y (on the floor). *
### GetWorkingPlayAreaSize(System.Single*,System.Single*)
Returns the width and depth of the Play Area (formerly named Soft Bounds) in X and Z from the working copy. * Tracking space center (0,0,0) is the center of the Play Area.
### GetWorkingSeatedZeroPoseToRawTrackingPose(vr.HmdMatrix34_t*)
Returns the preferred seated position from the working copy.
### GetWorkingStandingZeroPoseToRawTrackingPose(vr.HmdMatrix34_t*)
Returns the standing origin from the working copy.
### HideWorkingSetPreview
Hides the chaperone data in the working set to preview in the compositor (if it was visible).
### ReloadFromDisk(vr.EChaperoneConfigFile)
Tear everything down and reload it from the file on disk
### RevertWorkingCopy
Reverts the working copy to match the live chaperone calibration. * To modify existing data this MUST be do WHILE getting a non-error ChaperoneCalibrationStatus. * Only after this should you do gets and sets on the existing data.
### RoomSetupStarting
Fire an event that the tracking system can use to know room setup is about to begin. This lets the tracking * system make any last minute adjustments that should be incorporated into the new setup. If the user is adjusting * live in HMD using a tweak tool, keep in mind that calling this might cause the user to see the room jump.
### SetWorkingCollisionBoundsInfo(vr.HmdQuad_t*,System.UInt32)
Sets the Collision Bounds in the working copy.
### SetWorkingPerimeter(vr.HmdVector2_t*,System.UInt32)
Sets the Collision Bounds in the working copy.
### SetWorkingPlayAreaSize(System.Single,System.Single)
Sets the Play Area in the working copy.
### SetWorkingSeatedZeroPoseToRawTrackingPose(vr.HmdMatrix34_t!System.Runtime.CompilerServices.IsConst*)
Sets the preferred seated position in the working copy.
### SetWorkingStandingZeroPoseToRawTrackingPose(vr.HmdMatrix34_t!System.Runtime.CompilerServices.IsConst*)
Sets the preferred standing position in the working copy.
### ShowWorkingSetPreview
Shows the chaperone data in the working set to preview in the compositor.

## IVRCompositor
Allows the application to interact with the compositor
### CanRenderScene
Returns true if the current process has the scene focus
### ClearLastSubmittedFrame
Clears the frame that was sent with the last call to Submit. This will cause the * compositor to show the grid until Submit is called again.
### ClearSkyboxOverride
Resets compositor skybox back to defaults.
### CompositorBringToFront
Brings the compositor window to the front. This is useful for covering any other window that may be on the HMD * and is obscuring the compositor window.
### CompositorDumpImages
Writes back buffer and stereo left/right pair from the application to a 'screenshots' folder in the SteamVR runtime root.
### CompositorGoToBack
Pushes the compositor window to the back. This is useful for allowing other applications to draw directly to the HMD.
### CompositorQuit
Tells the compositor process to clean up and exit. You do not need to call this function at shutdown. Under normal * circumstances the compositor will manage its own life cycle based on what applications are running.
### FadeGrid(System.Single,System.Boolean)
Fading the Grid in or out in fSeconds
### FadeToColor(System.Single,System.Single,System.Single,System.Single,System.Single,System.Boolean)
Fades the view on the HMD to the specified color. The fade will take fSeconds, and the color values are between * 0.0 and 1.0. This color is faded on top of the scene based on the alpha parameter. Removing the fade color instantly * would be FadeToColor( 0.0, 0.0, 0.0, 0.0, 0.0 ). Values are in un-premultiplied alpha space.
### ForceInterleavedReprojectionOn(System.Boolean)
Override interleaved reprojection logic to force on.
### ForceReconnectProcess
Force reconnecting to the compositor process.
### GetCumulativeStats(vr.Compositor_CumulativeStats*,System.UInt32)
Fills out stats accumulated for the last connected application. Pass in sizeof( Compositor_CumulativeStats ) as second parameter.
### GetCurrentFadeColor(System.Boolean)
Get current fade color value.
### GetCurrentGridAlpha
Get current alpha value of grid.
### GetCurrentSceneFocusProcess
Returns the process ID of the process that is currently rendering the scene
### GetFrameTimeRemaining
Returns the time in seconds left in the current (as identified by FrameTiming's frameIndex) frame. * Due to "running start", this value may roll over to the next frame before ever reaching 0.0.
### GetFrameTiming(vr.Compositor_FrameTiming*,System.UInt32)
Returns true if timing data is filled it. Sets oldest timing info if nFramesAgo is larger than the stored history. * Be sure to set timing.size = sizeof(Compositor_FrameTiming) on struct passed in before calling this function.
### GetFrameTimings(vr.Compositor_FrameTiming*,System.UInt32)
Interface for copying a range of timing data. Frames are returned in ascending order (oldest to newest) with the last being the most recent frame. * Only the first entry's m_nSize needs to be set, as the rest will be inferred from that. Returns total number of entries filled out.
### GetLastFrameRenderer
Returns the process ID of the process that rendered the last frame (or 0 if the compositor itself rendered the frame.) * Returns 0 when fading out from an app and the app's process Id when fading into an app.
### GetLastPoseForTrackedDeviceIndex(System.UInt32,vr.TrackedDevicePose_t*,vr.TrackedDevicePose_t*)
Interface for accessing last set of poses returned by WaitGetPoses one at a time. * Returns VRCompositorError_IndexOutOfRange if unDeviceIndex not less than k_unMaxTrackedDeviceCount otherwise VRCompositorError_None. * It is okay to pass NULL for either pose if you only want one of the values.
### GetLastPoses(vr.TrackedDevicePose_t*,System.UInt32,vr.TrackedDevicePose_t*,System.UInt32)
Get the last set of poses returned by WaitGetPoses.
### GetMirrorTextureD3D11(vr.EVREye,System.Void*,System.Void**)
Opens a shared D3D11 texture with the undistorted composited image for each eye. Use ReleaseMirrorTextureD3D11 when finished * instead of calling Release on the resource itself.
### GetMirrorTextureGL(vr.EVREye,System.UInt32*,System.Void**)
Access to mirror textures from OpenGL.
### GetTrackingSpace
Gets current tracking space returned by WaitGetPoses
### GetVulkanDeviceExtensionsRequired(VkPhysicalDevice_T*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,System.UInt32)
[Vulkan only] * return 0. Otherwise it returns the length of the number of bytes necessary to hold this string including the trailing * null. The string will be a space separated list of required device extensions to enable in VkCreateDevice
### GetVulkanInstanceExtensionsRequired(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,System.UInt32)
[Vulkan Only] * return 0. Otherwise it returns the length of the number of bytes necessary to hold this string including the trailing * null. The string will be a space separated list of-required instance extensions to enable in VkCreateInstance
### HideMirrorWindow
DEPRECATED: Closes the headset view, either as a window or docked widget.
### IsCurrentSceneFocusAppLoading
Indicates whether or not the current scene focus app is currently loading. This is inferred from its use of FadeGrid to * explicitly fade to the compositor to cover up the fact that it cannot render at a sustained full framerate during this time.
### IsFullscreen
Return whether the compositor is fullscreen
### IsMirrorWindowVisible
DEPRECATED: Returns true if the headset view (either as a window or docked widget) is shown.
### IsMotionSmoothingSupported
Indicates whether or not motion smoothing is supported by the current hardware.
### PostPresentHandoff
Call immediately after presenting your app's window (i.e. companion window) to unblock the compositor. * This is an optional call, which only needs to be used if you can't instead call WaitGetPoses immediately after Present. * For example, if your engine's render and game loop are not on separate threads, or blocking the render thread until 3ms before the next vsync would * introduce a deadlock of some sort. This function tells the compositor that you have finished all rendering after having Submitted buffers for both * eyes, and it is free to start its rendering work. This should only be called from the same thread you are rendering on.
### SetExplicitTimingMode(vr.EVRCompositorTimingMode)
[ Vulkan/D3D12 Only ] * There are two purposes for SetExplicitTimingMode: * 1. To get a more accurate GPU timestamp for when the frame begins in Vulkan/D3D12 applications. * 2. (Optional) To avoid having WaitGetPoses access the Vulkan queue so that the queue can be accessed from * another thread while WaitGetPoses is executing. * * More accurate GPU timestamp for the start of the frame is achieved by the application calling * SubmitExplicitTimingData immediately before its first submission to the Vulkan/D3D12 queue. * This is more accurate because normally this GPU timestamp is recorded during WaitGetPoses. In D3D11, * WaitGetPoses queues a GPU timestamp write, but it does not actually get submitted to the GPU until the * application flushes. By using SubmitExplicitTimingData, the timestamp is recorded at the same place for * Vulkan/D3D12 as it is for D3D11, resulting in a more accurate GPU time measurement for the frame. * * Avoiding WaitGetPoses accessing the Vulkan queue can be achieved using SetExplicitTimingMode as well. If this is desired, * the application should set the timing mode to Explicit_ApplicationPerformsPostPresentHandoff and *MUST* call PostPresentHandoff * itself. If these conditions are met, then WaitGetPoses is guaranteed not to access the queue. Note that PostPresentHandoff * and SubmitExplicitTimingData will access the queue, so only WaitGetPoses becomes safe for accessing the queue from another * thread.
### SetSkyboxOverride(vr.Texture_t!System.Runtime.CompilerServices.IsConst*,System.UInt32)
Override the skybox used in the compositor (e.g. for during level loads when the app can't feed scene images fast enough) * Order is Front, Back, Left, Right, Top, Bottom. If only a single texture is passed, it is assumed in lat-long format. * If two are passed, it is assumed a lat-long stereo pair.
### SetTrackingSpace(vr.ETrackingUniverseOrigin)
Sets tracking space returned by WaitGetPoses
### ShouldAppRenderWithLowResources
Let an app know it should be rendering with low resources.
### ShowMirrorWindow
DEPRECATED: Opens the headset view (as either a window or docked widget depending on user's preferences) that displays what the user * sees in the headset.
### Submit(vr.EVREye,vr.Texture_t!System.Runtime.CompilerServices.IsConst*,vr.VRTextureBounds_t!System.Runtime.CompilerServices.IsConst*,vr.EVRSubmitFlags)
Updated scene texture to display. If pBounds is NULL the entire texture will be used. If called from an OpenGL app, consider adding a glFlush after * Submitting both frames to signal the driver to start processing, otherwise it may wait until the command buffer fills up, causing the app to miss frames. * * OpenGL dirty state: * glBindTexture * * Return codes: * - IsNotSceneApplication (make sure to call VR_Init with VRApplicaiton_Scene) * - DoNotHaveFocus (some other app has taken focus) * - TextureIsOnWrongDevice (application did not use proper AdapterIndex - see IVRSystem.GetDXGIOutputInfo) * - SharedTexturesNotSupported (application needs to call CreateDXGIFactory1 or later before creating DX device) * - TextureUsesUnsupportedFormat (scene textures must be compatible with DXGI sharing rules - e.g. uncompressed, no mips, etc.) * - InvalidTexture (usually means bad arguments passed in) * - AlreadySubmitted (app has submitted two left textures or two right textures in a single frame - i.e. before calling WaitGetPoses again)
### SubmitExplicitTimingData
[ Vulkan/D3D12 Only ] * Submit explicit timing data. When SetExplicitTimingMode is true, this must be called immediately before * the application's first vkQueueSubmit (Vulkan) or ID3D12CommandQueue::ExecuteCommandLists (D3D12) of each frame. * This function will insert a GPU timestamp write just before the application starts its rendering. This function * will perform a vkQueueSubmit on Vulkan so must not be done simultaneously with VkQueue operations on another thread. * Returns VRCompositorError_RequestFailed if SetExplicitTimingMode is not enabled.
### SuspendRendering(System.Boolean)
Temporarily suspends rendering (useful for finer control over scene transitions).
### WaitGetPoses(vr.TrackedDevicePose_t*,System.UInt32,vr.TrackedDevicePose_t*,System.UInt32)
Scene applications should call this function to get poses to render with (and optionally poses predicted an additional frame out to use for gameplay). * This function will block until "running start" milliseconds before the start of the frame, and should be called at the last moment before needing to * start rendering. * * Return codes: * - IsNotSceneApplication (make sure to call VR_Init with VRApplicaiton_Scene) * - DoNotHaveFocus (some other app has taken focus - this will throttle the call to 10hz to reduce the impact on that app)
### vr.IVRDebug.BeginVrProfilerEvent(System.UInt64*)
Create an vr profiler duration event (line) * The current time will be used as the timestamp for the start of the line. * On success, pHandleOut will contain a handle valid for terminating this event.
### vr.IVRDebug.DriverDebugRequest(System.UInt32,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,System.UInt32)
Sends a request to the driver for the specified device and returns the response. The maximum response size is 32k, * but this method can be called with a smaller buffer. If the response exceeds the size of the buffer, it is truncated. * The size of the response including its terminating null is returned.
### vr.IVRDebug.EmitVrProfilerEvent(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)
Create a vr profiler discrete event (point) * The event will be associated with the message provided in pchMessage, and the current * time will be used as the event timestamp.
### vr.IVRDebug.FinishVrProfilerEvent(System.UInt64,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)
Terminate a vr profiler event * The event associated with hHandle will be considered completed when this method is called. * The current time will be used assocaited to the termination time of the event, and * pchMessage will be used as the event title.
### vr.IVRDriverManager.GetDriverName(System.UInt32,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,System.UInt32)
Returns the length of the number of bytes necessary to hold this string including the trailing null.

## IVRExtendedDisplay
NOTE: Use of this interface is not recommended in production applications. It will not work for displays which use * direct-to-display mode. Creating our own window is also incompatible with the VR compositor and is not available when the compositor is running.
### GetDXGIOutputInfo(System.Int32*,System.Int32*)
[D3D10/11 Only] * Returns the adapter index and output index that the user should pass into EnumAdapters and EnumOutputs * to create the device and swap chain in DX10 and DX11. If an error occurs both indices will be set to -1.
### GetEyeOutputViewport(vr.EVREye,System.UInt32*,System.UInt32*,System.UInt32*,System.UInt32*)
Gets the viewport in the frame buffer to draw the output of the distortion into
### GetWindowBounds(System.Int32*,System.Int32*,System.UInt32*,System.UInt32*)
Size and position that the window needs to be on the VR display.
### vr.IVRInput.DecompressSkeletalBoneData(System.Void!System.Runtime.CompilerServices.IsConst*,System.UInt32,vr.EVRSkeletalTransformSpace,vr.VRBoneTransform_t*,System.UInt32)
Turns a compressed buffer from GetSkeletalBoneDataCompressed and turns it back into a bone transform array.
### vr.IVRInput.GetActionBindingInfo(System.UInt64,vr.InputBindingInfo_t*,System.UInt32,System.UInt32,System.UInt32*)
Retrieves useful information about the bindings for an action
### vr.IVRInput.GetActionHandle(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.UInt64*)
Returns a handle for an action. This handle is used for all performance-sensitive calls.
### vr.IVRInput.GetActionOrigins(System.UInt64,System.UInt64,System.UInt64*,System.UInt32)
Retrieve origin handles for an action
### vr.IVRInput.GetActionSetHandle(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.UInt64*)
Returns a handle for an action set. This handle is used for all performance-sensitive calls.
### vr.IVRInput.GetAnalogActionData(System.UInt64,vr.InputAnalogActionData_t*,System.UInt32,System.UInt64)
Reads the state of an analog action given its handle. This will return VRInputError_WrongType if the type of * action is something other than analog
### vr.IVRInput.GetBoneCount(System.UInt64,System.UInt32*)
Reads the number of bones in skeleton associated with the given action
### vr.IVRInput.GetBoneHierarchy(System.UInt64,System.Int32*,System.UInt32)
Fills the given array with the index of each bone's parent in the skeleton associated with the given action
### vr.IVRInput.GetBoneName(System.UInt64,System.Int32,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,System.UInt32)
Fills the given buffer with the name of the bone at the given index in the skeleton associated with the given action
### vr.IVRInput.GetDigitalActionData(System.UInt64,vr.InputDigitalActionData_t*,System.UInt32,System.UInt64)
Reads the state of a digital action given its handle. This will return VRInputError_WrongType if the type of * action is something other than digital
### vr.IVRInput.GetInputSourceHandle(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.UInt64*)
Returns a handle for any path in the input system. E.g. /user/hand/right
### vr.IVRInput.GetOriginLocalizedName(System.UInt64,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,System.UInt32,System.Int32)
Retrieves the name of the origin in the current language. unStringSectionsToInclude is a bitfield of values in EVRInputStringBits that allows the application to specify which parts of the origin's information it wants a string for.
### vr.IVRInput.GetOriginTrackedDeviceInfo(System.UInt64,vr.InputOriginInfo_t*,System.UInt32)
Retrieves useful information for the origin of this action
### vr.IVRInput.GetPoseActionDataForNextFrame(System.UInt64,vr.ETrackingUniverseOrigin,vr.InputPoseActionData_t*,System.UInt32,System.UInt64)
Reads the state of a pose action given its handle. The returned values will match the values returned * by the last call to IVRCompositor::WaitGetPoses().
### vr.IVRInput.GetPoseActionDataRelativeToNow(System.UInt64,vr.ETrackingUniverseOrigin,System.Single,vr.InputPoseActionData_t*,System.UInt32,System.UInt64)
Reads the state of a pose action given its handle for the number of seconds relative to now. This * will generally be called with negative times from the fUpdateTime fields in other actions.
### vr.IVRInput.GetSkeletalActionData(System.UInt64,vr.InputSkeletalActionData_t*,System.UInt32)
Reads the state of a skeletal action given its handle.
### vr.IVRInput.GetSkeletalBoneData(System.UInt64,vr.EVRSkeletalTransformSpace,vr.EVRSkeletalMotionRange,vr.VRBoneTransform_t*,System.UInt32)
Reads the state of the skeletal bone data associated with this action and copies it into the given buffer.
### vr.IVRInput.GetSkeletalBoneDataCompressed(System.UInt64,vr.EVRSkeletalMotionRange,System.Void*,System.UInt32,System.UInt32*)
Reads the state of the skeletal bone data in a compressed form that is suitable for * sending over the network. The required buffer size will never exceed ( sizeof(VR_BoneTransform_t)*boneCount + 2). * Usually the size will be much smaller.
### vr.IVRInput.GetSkeletalReferenceTransforms(System.UInt64,vr.EVRSkeletalTransformSpace,vr.EVRSkeletalReferencePose,vr.VRBoneTransform_t*,System.UInt32)
Fills the given buffer with the transforms for a specific static skeletal reference pose
### vr.IVRInput.GetSkeletalSummaryData(System.UInt64,vr.EVRSummaryType,vr.VRSkeletalSummaryData_t*)
Reads summary information about the current pose of the skeleton associated with the given action.
### vr.IVRInput.GetSkeletalTrackingLevel(System.UInt64,vr.EVRSkeletalTrackingLevel*)
Reads the level of accuracy to which the controller is able to track the user to recreate a skeletal pose
### vr.IVRInput.SetActionManifestPath(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)
Sets the path to the action manifest JSON file that is used by this application. If this information * was set on the Steam partner site, calls to this function are ignored. If the Steam partner site * setting and the path provided by this call are different, VRInputError_MismatchedActionManifest is returned. * This call must be made before the first call to UpdateActionState or IVRSystem::PollNextEvent.
### vr.IVRInput.ShowActionOrigins(System.UInt64,System.UInt64)
Shows the current binding for the action in-headset
### vr.IVRInput.ShowBindingsForActionSet(vr.VRActiveActionSet_t*,System.UInt32,System.UInt32,System.UInt64)
Shows the current binding all the actions in the specified action sets
### vr.IVRInput.TriggerHapticVibrationAction(System.UInt64,System.Single,System.Single,System.Single,System.Single,System.UInt64)
Triggers a haptic event as described by the specified action
### vr.IVRInput.UpdateActionState(vr.VRActiveActionSet_t*,System.UInt32,System.UInt32)
Reads the current state into all actions. After this call, the results of Get*Action calls * will be the same until the next call to UpdateActionState.
### vr.IVRIOBuffer.Close(System.UInt64)
closes a previously opened or created buffer
### vr.IVRIOBuffer.HasReaders(System.UInt64)
inexpensively checks for readers to allow writers to fast-fail potentially expensive copies and writes.
### vr.IVRIOBuffer.Open(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,vr.EIOBufferMode,System.UInt32,System.UInt32,System.UInt64*)
opens an existing or creates a new IOBuffer of unSize bytes
### vr.IVRIOBuffer.PropertyContainer(System.UInt64)
retrieves the property container of an buffer.
### vr.IVRIOBuffer.Read(System.UInt64,System.Void*,System.UInt32,System.UInt32*)
reads up to unBytes from buffer into *pDst, returning number of bytes read in *punRead
### vr.IVRIOBuffer.Write(System.UInt64,System.Void*,System.UInt32)
writes unBytes of data from *pSrc into a buffer.

## IVRNotifications
Allows notification sources to interact with the VR system This current interface is not yet implemented. Do not use yet.
### CreateNotification(System.UInt64,System.UInt64,vr.EVRNotificationType,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,vr.EVRNotificationStyle,vr.NotificationBitmap_t!System.Runtime.CompilerServices.IsConst*,System.UInt32*)
Create a notification and enqueue it to be shown to the user. * An overlay handle is required to create a notification, as otherwise it would be impossible for a user to act on it. * To create a two-line notification, use a line break ('\n') to split the text into two lines. * The pImage argument may be NULL, in which case the specified overlay's icon will be used instead.
### RemoveNotification(System.UInt32)
Destroy a notification, hiding it first if it currently shown to the user.
### vr.IVROverlay.ClearOverlayTexture(System.UInt64)
Use this to tell the overlay system to release the texture set for this overlay.
### vr.IVROverlay.CloseMessageOverlay
If the calling process owns the overlay and it's open, this will close it. *
### vr.IVROverlay.ComputeOverlayIntersection(System.UInt64,vr.VROverlayIntersectionParams_t!System.Runtime.CompilerServices.IsConst*,vr.VROverlayIntersectionResults_t*)
Computes the overlay-space pixel coordinates of where the ray intersects the overlay with the * specified settings. Returns false if there is no intersection.
### vr.IVROverlay.CreateDashboardOverlay(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.UInt64*,System.UInt64*)
Creates a dashboard overlay and returns its handle
### vr.IVROverlay.CreateOverlay(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.UInt64*)
Creates a new named overlay. All overlays start hidden and with default settings.
### vr.IVROverlay.DestroyOverlay(System.UInt64)
Destroys the specified overlay. When an application calls VR_Shutdown all overlays created by that app are * automatically destroyed.
### vr.IVROverlay.FindOverlay(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.UInt64*)
Finds an existing overlay with the specified key.
### vr.IVROverlay.GetDashboardOverlaySceneProcess(System.UInt64,System.UInt32*)
Gets the process ID that this dashboard overlay requires to have scene focus
### vr.IVROverlay.GetGamepadFocusOverlay
Returns the current Gamepad focus overlay
### vr.IVROverlay.GetKeyboardText(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,System.UInt32)
Get the text that was entered into the text input *
### vr.IVROverlay.GetOverlayAlpha(System.UInt64,System.Single*)
Gets the alpha of the overlay quad. By default overlays are rendering at 100 percent alpha (1.0).
### vr.IVROverlay.GetOverlayAutoCurveDistanceRangeInMeters(System.UInt64,System.Single*,System.Single*)
For high-quality curved overlays only, gets the distance range in meters from the overlay used to automatically curve * the surface around the viewer. Min is distance is when the surface will be most curved. Max is when least curved.
### vr.IVROverlay.GetOverlayColor(System.UInt64,System.Single*,System.Single*,System.Single*)
Gets the color tint of the overlay quad.
### vr.IVROverlay.GetOverlayDualAnalogTransform(System.UInt64,vr.EDualAnalogWhich,vr.HmdVector2_t*,System.Single*)
Gets the analog input to Dual Analog coordinate scale for the specified overlay.
### vr.IVROverlay.GetOverlayErrorNameFromEnum(vr.EVROverlayError)
returns a string that corresponds with the specified overlay error. The string will be the name * of the error enum value for all valid error codes
### vr.IVROverlay.GetOverlayFlag(System.UInt64,vr.VROverlayFlags,System.Boolean*)
Sets flag setting for a given overlay
### vr.IVROverlay.GetOverlayImageData(System.UInt64,System.Void*,System.UInt32,System.UInt32*,System.UInt32*)
Gets the raw image data from an overlay. Overlay image data is always returned as RGBA data, 4 bytes per pixel. If the buffer is not large enough, width and height * will be set and VROverlayError_ArrayTooSmall is returned.
### vr.IVROverlay.GetOverlayInputMethod(System.UInt64,vr.VROverlayInputMethod*)
Returns the current input settings for the specified overlay.
### vr.IVROverlay.GetOverlayKey(System.UInt64,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,System.UInt32,vr.EVROverlayError*)
Fills the provided buffer with the string key of the overlay. Returns the size of buffer required to store the key, including * the terminating null character. k_unVROverlayMaxKeyLength will be enough bytes to fit the string.
### vr.IVROverlay.GetOverlayMouseScale(System.UInt64,vr.HmdVector2_t*)
Gets the mouse scaling factor that is used for mouse events. The actual texture may be a different size, but this is * typically the size of the underlying UI in pixels.
### vr.IVROverlay.GetOverlayName(System.UInt64,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,System.UInt32,vr.EVROverlayError*)
Fills the provided buffer with the friendly name of the overlay. Returns the size of buffer required to store the key, including * the terminating null character. k_unVROverlayMaxNameLength will be enough bytes to fit the string.
### vr.IVROverlay.GetOverlayRenderingPid(System.UInt64)
Gets the pid that is allowed to render to this overlay
### vr.IVROverlay.GetOverlayRenderModel(System.UInt64,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,System.UInt32,vr.HmdColor_t*,vr.EVROverlayError*)
Gets render model to draw behind this overlay
### vr.IVROverlay.GetOverlaySortOrder(System.UInt64,System.UInt32*)
Gets the sort order of the overlay. See SetOverlaySortOrder for how this works.
### vr.IVROverlay.GetOverlayTexelAspect(System.UInt64,System.Single*)
Gets the aspect ratio of the texels in the overlay. Defaults to 1.0
### vr.IVROverlay.GetOverlayTexture(System.UInt64,System.Void**,System.Void*,System.UInt32*,System.UInt32*,System.UInt32*,vr.ETextureType*,vr.EColorSpace*,vr.VRTextureBounds_t*)
Get the native texture handle/device for an overlay you have created. * On windows this handle will be a ID3D11ShaderResourceView with a ID3D11Texture2D bound. * * The texture will always be sized to match the backing texture you supplied in SetOverlayTexture above. * * You MUST call ReleaseNativeOverlayHandle() with pNativeTextureHandle once you are done with this texture. * * pNativeTextureHandle is an OUTPUT, it will be a pointer to a ID3D11ShaderResourceView *. * pNativeTextureRef is an INPUT and should be a ID3D11Resource *. The device used by pNativeTextureRef will be used to bind pNativeTextureHandle.
### vr.IVROverlay.GetOverlayTextureBounds(System.UInt64,vr.VRTextureBounds_t*)
Gets the part of the texture to use for the overlay. UV Min is the upper left corner and UV Max is the lower right corner.
### vr.IVROverlay.GetOverlayTextureColorSpace(System.UInt64,vr.EColorSpace*)
Gets the overlay's current colorspace setting.
### vr.IVROverlay.GetOverlayTextureSize(System.UInt64,System.UInt32*,System.UInt32*)
Get the size of the overlay texture
### vr.IVROverlay.GetOverlayTransformAbsolute(System.UInt64,vr.ETrackingUniverseOrigin*,vr.HmdMatrix34_t*)
Gets the transform if it is absolute. Returns an error if the transform is some other type.
### vr.IVROverlay.GetOverlayTransformOverlayRelative(System.UInt64,System.UInt64*,vr.HmdMatrix34_t*)
Gets the transform if it is relative to another overlay. Returns an error if the transform is some other type.
### vr.IVROverlay.GetOverlayTransformTrackedDeviceComponent(System.UInt64,System.UInt32*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,System.UInt32)
Gets the transform information when the overlay is rendering on a component.
### vr.IVROverlay.GetOverlayTransformTrackedDeviceRelative(System.UInt64,System.UInt32*,vr.HmdMatrix34_t*)
Gets the transform if it is relative to a tracked device. Returns an error if the transform is some other type.
### vr.IVROverlay.GetOverlayTransformType(System.UInt64,vr.VROverlayTransformType*)
Returns the transform type of this overlay.
### vr.IVROverlay.GetOverlayWidthInMeters(System.UInt64,System.Single*)
Returns the width of the overlay quad in meters. By default overlays are rendered on a quad that is 1 meter across
### vr.IVROverlay.GetPrimaryDashboardDevice
Returns the tracked device that has the laser pointer in the dashboard
### vr.IVROverlay.GetTransformForOverlayCoordinates(System.UInt64,vr.ETrackingUniverseOrigin,vr.HmdVector2_t,vr.HmdMatrix34_t*)
Get the transform in 3d space associated with a specific 2d point in the overlay's coordinate space (where 0,0 is the lower left). -Z points out of the overlay
### vr.IVROverlay.HideKeyboard
Hide the virtual keyboard *
### vr.IVROverlay.HideOverlay(System.UInt64)
Hides the VR overlay. For dashboard overlays, only the Dashboard Manager is allowed to call this.
### vr.IVROverlay.IsActiveDashboardOverlay(System.UInt64)
returns true if the dashboard is visible and the specified overlay is the active system Overlay
### vr.IVROverlay.IsDashboardVisible
Returns true if the dashboard is visible
### vr.IVROverlay.IsHoverTargetOverlay(System.UInt64)
Returns true if the specified overlay is the hover target. An overlay is the hover target when it is the last overlay "moused over" * by the virtual mouse pointer
### vr.IVROverlay.IsOverlayVisible(System.UInt64)
Returns true if the overlay is visible.
### vr.IVROverlay.MoveGamepadFocusToNeighbor(vr.EOverlayDirection,System.UInt64)
Changes the Gamepad focus from one overlay to one of its neighbors. Returns VROverlayError_NoNeighbor if there is no * neighbor in that direction
### vr.IVROverlay.PollNextOverlayEvent(System.UInt64,vr.VREvent_t*,System.UInt32)
Returns true and fills the event with the next event on the overlay's event queue, if there is one. * If there are no events this method returns false. uncbVREvent should be the size in bytes of the VREvent_t struct
### vr.IVROverlay.ReleaseNativeOverlayHandle(System.UInt64,System.Void*)
Release the pNativeTextureHandle provided from the GetOverlayTexture call, this allows the system to free the underlying GPU resources for this object, * so only do it once you stop rendering this texture.
### vr.IVROverlay.SetDashboardOverlaySceneProcess(System.UInt64,System.UInt32)
Sets the dashboard overlay to only appear when the specified process ID has scene focus
### vr.IVROverlay.SetGamepadFocusOverlay(System.UInt64)
Sets the current Gamepad focus overlay
### vr.IVROverlay.SetKeyboardPositionForOverlay(System.UInt64,vr.HmdRect2_t)
Set the position of the keyboard in overlay space by telling it to avoid a rectangle in the overlay. Rectangle coords have (0,0) in the bottom left *
### vr.IVROverlay.SetKeyboardTransformAbsolute(vr.ETrackingUniverseOrigin,vr.HmdMatrix34_t!System.Runtime.CompilerServices.IsConst*)
Set the position of the keyboard in world space *
### vr.IVROverlay.SetOverlayAlpha(System.UInt64,System.Single)
Sets the alpha of the overlay quad. Use 1.0 for 100 percent opacity to 0.0 for 0 percent opacity.
### vr.IVROverlay.SetOverlayAutoCurveDistanceRangeInMeters(System.UInt64,System.Single,System.Single)
For high-quality curved overlays only, sets the distance range in meters from the overlay used to automatically curve * the surface around the viewer. Min is distance is when the surface will be most curved. Max is when least curved.
### vr.IVROverlay.SetOverlayColor(System.UInt64,System.Single,System.Single,System.Single)
Sets the color tint of the overlay quad. Use 0.0 to 1.0 per channel.
### vr.IVROverlay.SetOverlayDualAnalogTransform(System.UInt64,vr.EDualAnalogWhich,vr.HmdVector2_t!System.Runtime.CompilerServices.IsConst*,System.Single)
Sets the analog input to Dual Analog coordinate scale for the specified overlay.
### vr.IVROverlay.SetOverlayFlag(System.UInt64,vr.VROverlayFlags,System.Boolean)
Specify flag setting for a given overlay
### vr.IVROverlay.SetOverlayFromFile(System.UInt64,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)
Separate interface for providing the image through a filename: can be png or jpg, and should not be bigger than 1920x1080. * This function can only be called by the overlay's renderer process
### vr.IVROverlay.SetOverlayInputMethod(System.UInt64,vr.VROverlayInputMethod)
Sets the input settings for the specified overlay.
### vr.IVROverlay.SetOverlayIntersectionMask(System.UInt64,vr.VROverlayIntersectionMaskPrimitive_t*,System.UInt32,System.UInt32)
Sets a list of primitives to be used for controller ray intersection * typically the size of the underlying UI in pixels (not in world space).
### vr.IVROverlay.SetOverlayMouseScale(System.UInt64,vr.HmdVector2_t!System.Runtime.CompilerServices.IsConst*)
Sets the mouse scaling factor that is used for mouse events. The actual texture may be a different size, but this is * typically the size of the underlying UI in pixels (not in world space).
### vr.IVROverlay.SetOverlayName(System.UInt64,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)
set the name to use for this overlay
### vr.IVROverlay.SetOverlayNeighbor(vr.EOverlayDirection,System.UInt64,System.UInt64)
Sets an overlay's neighbor. This will also set the neighbor of the "to" overlay * to point back to the "from" overlay. If an overlay's neighbor is set to invalid both * ends will be cleared
### vr.IVROverlay.SetOverlayRaw(System.UInt64,System.Void*,System.UInt32,System.UInt32,System.UInt32)
Separate interface for providing the data as a stream of bytes, but there is an upper bound on data * that can be sent. This function can only be called by the overlay's renderer process.
### vr.IVROverlay.SetOverlayRenderingPid(System.UInt64,System.UInt32)
Sets the pid that is allowed to render to this overlay (the creator pid is always allow to render), * by default this is the pid of the process that made the overlay
### vr.IVROverlay.SetOverlayRenderModel(System.UInt64,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,vr.HmdColor_t!System.Runtime.CompilerServices.IsConst*)
Sets render model to draw behind this overlay and the vertex color to use, pass null for pColor to match the overlays vertex color. The model is scaled by the same amount as the overlay, with a default of 1m.
### vr.IVROverlay.SetOverlaySortOrder(System.UInt64,System.UInt32)
Sets the rendering sort order for the overlay. Overlays are rendered this order: * Overlays owned by the scene application * Overlays owned by some other application * * Within a category overlays are rendered lowest sort order to highest sort order. Overlays with the same * sort order are rendered back to front base on distance from the HMD. * * Sort order defaults to 0.
### vr.IVROverlay.SetOverlayTexelAspect(System.UInt64,System.Single)
Sets the aspect ratio of the texels in the overlay. 1.0 means the texels are square. 2.0 means the texels * are twice as wide as they are tall. Defaults to 1.0.
### vr.IVROverlay.SetOverlayTexture(System.UInt64,vr.Texture_t!System.Runtime.CompilerServices.IsConst*)
Texture to draw for the overlay. This function can only be called by the overlay's creator or renderer process (see SetOverlayRenderingPid) . * * OpenGL dirty state: * glBindTexture
### vr.IVROverlay.SetOverlayTextureBounds(System.UInt64,vr.VRTextureBounds_t!System.Runtime.CompilerServices.IsConst*)
Sets the part of the texture to use for the overlay. UV Min is the upper left corner and UV Max is the lower right corner.
### vr.IVROverlay.SetOverlayTextureColorSpace(System.UInt64,vr.EColorSpace)
Sets the colorspace the overlay texture's data is in. Defaults to 'auto'. * If the texture needs to be resolved, you should call SetOverlayTexture with the appropriate colorspace instead.
### vr.IVROverlay.SetOverlayTransformAbsolute(System.UInt64,vr.ETrackingUniverseOrigin,vr.HmdMatrix34_t!System.Runtime.CompilerServices.IsConst*)
Sets the transform to absolute tracking origin.
### vr.IVROverlay.SetOverlayTransformOverlayRelative(System.UInt64,System.UInt64,vr.HmdMatrix34_t!System.Runtime.CompilerServices.IsConst*)
Sets the transform to relative to the transform of the specified overlay. This overlays visibility will also track the parents visibility
### vr.IVROverlay.SetOverlayTransformTrackedDeviceComponent(System.UInt64,System.UInt32,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)
Sets the transform to draw the overlay on a rendermodel component mesh instead of a quad. This will only draw when the system is * drawing the device. Overlays with this transform type cannot receive mouse events.
### vr.IVROverlay.SetOverlayTransformTrackedDeviceRelative(System.UInt64,System.UInt32,vr.HmdMatrix34_t!System.Runtime.CompilerServices.IsConst*)
Sets the transform to relative to the transform of the specified tracked device.
### vr.IVROverlay.SetOverlayWidthInMeters(System.UInt64,System.Single)
Sets the width of the overlay quad in meters. By default overlays are rendered on a quad that is 1 meter across
### vr.IVROverlay.ShowDashboard(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)
Shows the dashboard.
### vr.IVROverlay.ShowKeyboard(vr.EGamepadTextInputMode,vr.EGamepadTextInputLineMode,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.UInt32,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Boolean,System.UInt64)
Show the virtual keyboard to accept input *
### vr.IVROverlay.ShowMessageOverlay(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)
Show the message overlay. This will block and return you a result. *
### vr.IVROverlay.ShowOverlay(System.UInt64)
Shows the VR overlay. For dashboard overlays, only the Dashboard Manager is allowed to call this.
### vr.IVRRenderModels.FreeRenderModel(vr.RenderModel_t*)
Frees a previously returned render model * It is safe to call this on a null ptr.
### vr.IVRRenderModels.FreeTexture(vr.RenderModel_TextureMap_t*)
Frees a previously returned texture * It is safe to call this on a null ptr.
### vr.IVRRenderModels.FreeTextureD3D11(System.Void*)
Use this to free textures created with LoadTextureD3D11_Async instead of calling Release on them.
### vr.IVRRenderModels.GetComponentButtonMask(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)
Get the button mask for all buttons associated with this component * If no buttons (or axes) are associated with this component, return 0 * Note: multiple components may be associated with the same button. Ex: two grip buttons on a single controller. * Note: A single component may be associated with multiple buttons. Ex: A trackpad which also provides "D-pad" functionality
### vr.IVRRenderModels.GetComponentCount(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)
Returns the number of components of the specified render model. * Components are useful when client application wish to draw, label, or otherwise interact with components of tracked objects. * Examples controller components: * renderable things such as triggers, buttons * non-renderable things which include coordinate systems such as 'tip', 'base', a neutral controller agnostic hand-pose * If all controller components are enumerated and rendered, it will be equivalent to drawing the traditional render model * Returns 0 if components not supported, >0 otherwise
### vr.IVRRenderModels.GetComponentName(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.UInt32,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,System.UInt32)
Use this to get the names of available components. Index does not correlate to a tracked device index, but * is only used for iterating over all available components. If the index is out of range, this function will return 0. * Otherwise, it will return the size of the buffer required for the name.
### vr.IVRRenderModels.GetComponentRenderModelName(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,System.UInt32)
Use this to get the render model name for the specified rendermode/component combination, to be passed to LoadRenderModel. * If the component name is out of range, this function will return 0. * Otherwise, it will return the size of the buffer required for the name.
### vr.IVRRenderModels.GetComponentState(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,vr.VRControllerState001_t!System.Runtime.CompilerServices.IsConst*,vr.RenderModel_ControllerMode_State_t!System.Runtime.CompilerServices.IsConst*,vr.RenderModel_ComponentState_t*)
This version of GetComponentState takes a controller state block instead of an action origin. This function is deprecated. You should use the new input system and GetComponentStateForDevicePath instead.
### vr.IVRRenderModels.GetComponentStateForDevicePath(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.UInt64,vr.RenderModel_ControllerMode_State_t!System.Runtime.CompilerServices.IsConst*,vr.RenderModel_ComponentState_t*)
Use this to query information about the component, as a function of the controller state. * * For dynamic controller components (ex: trigger) values will reflect component motions * For static components this will return a consistent value independent of the VRControllerState_t * * If the pchRenderModelName or pchComponentName is invalid, this will return false (and transforms will be set to identity). * Otherwise, return true * Note: For dynamic objects, visibility may be dynamic. (I.e., true/false will be returned based on controller state and controller mode state )
### vr.IVRRenderModels.GetRenderModelCount
Returns the number of available render models.
### vr.IVRRenderModels.GetRenderModelErrorNameFromEnum(vr.EVRRenderModelError)
Returns a string for a render model error
### vr.IVRRenderModels.GetRenderModelName(System.UInt32,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,System.UInt32)
Use this to get the names of available render models. Index does not correlate to a tracked device index, but * is only used for iterating over all available render models. If the index is out of range, this function will return 0. * Otherwise, it will return the size of the buffer required for the name.
### vr.IVRRenderModels.GetRenderModelOriginalPath(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,System.UInt32,vr.EVRRenderModelError*)
Provides a render model path that will load the unskinned model if the model name provided has been replace by the user. If the model * hasn't been replaced the path value will still be a valid path to load the model. Pass this to LoadRenderModel_Async, etc. to load the * model.
### vr.IVRRenderModels.GetRenderModelThumbnailURL(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,System.UInt32,vr.EVRRenderModelError*)
Returns the URL of the thumbnail image for this rendermodel
### vr.IVRRenderModels.LoadIntoTextureD3D11_Async(System.Int32,System.Void*)
Helper function to copy the bits into an existing texture.
### vr.IVRRenderModels.LoadRenderModel_Async(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,vr.RenderModel_t**)
Loads and returns a render model for use in the application. pchRenderModelName should be a render model name * from the Prop_RenderModelName_String property or an absolute path name to a render model on disk. * * The resulting render model is valid until VR_Shutdown() is called or until FreeRenderModel() is called. When the * application is finished with the render model it should call FreeRenderModel() to free the memory associated * with the model. * * The method returns VRRenderModelError_Loading while the render model is still being loaded. * The method returns VRRenderModelError_None once loaded successfully, otherwise will return an error.
### vr.IVRRenderModels.LoadTexture_Async(System.Int32,vr.RenderModel_TextureMap_t**)
Loads and returns a texture for use in the application.
### vr.IVRRenderModels.LoadTextureD3D11_Async(System.Int32,System.Void*,System.Void**)
Creates a D3D11 texture and loads data into it.
### vr.IVRRenderModels.RenderModelHasComponent(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)
Returns true if the render model has a component with the specified name
### vr.IVRResources.GetResourceFullPath(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,System.UInt32)
Provides the full path to the specified resource. Resource names can include named directories for * drivers and other things, and this resolves all of those and returns the actual physical path. * pchResourceTypeDirectory is the subdirectory of resources to look in.
### vr.IVRResources.LoadSharedResource(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,System.UInt32)
Loads the specified resource into the provided buffer if large enough. * Returns the size in bytes of the buffer required to hold the specified resource.

## IVRScreenshots
Allows the application to generate screenshots
### GetScreenshotPropertyFilename(System.UInt32,vr.EVRScreenshotPropertyFilenames,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,System.UInt32,vr.EVRScreenshotError*)
Get the filename for the preview or vr image (see * vr::EScreenshotPropertyFilenames). The return value is * the size of the string.
### GetScreenshotPropertyType(System.UInt32,vr.EVRScreenshotError*)
When your application receives a * VREvent_RequestScreenshot event, call these functions to get * the details of the screenshot request.
### HookScreenshot(vr.EVRScreenshotType!System.Runtime.CompilerServices.IsConst*,System.Int32)
Called by the running VR application to indicate that it * wishes to be in charge of screenshots. If the * application does not call this, the Compositor will only * support VRScreenshotType_Stereo screenshots that will be * captured without notification to the running app. * Once hooked your application will receive a * VREvent_RequestScreenshot event when the user presses the * buttons to take a screenshot.
### RequestScreenshot(System.UInt32*,vr.EVRScreenshotType,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)
Request a screenshot of the requested type. * A request of the VRScreenshotType_Stereo type will always * work. Other types will depend on the underlying application * support. * The first file name is for the preview image and should be a * regular screenshot (ideally from the left eye). The second * is the VR screenshot in the correct format. They should be * in the same aspect ratio. Formats per type: * VRScreenshotType_Mono: the VR filename is ignored (can be * nullptr), this is a normal flat single shot. * VRScreenshotType_Stereo: The VR image should be a * side-by-side with the left eye image on the left. * VRScreenshotType_Cubemap: The VR image should be six square * images composited horizontally. * VRScreenshotType_StereoPanorama: above/below with left eye * panorama being the above image. Image is typically square * with the panorama being 2x horizontal. * * Note that the VR dashboard will call this function when * the user presses the screenshot binding (currently System * Button + Trigger). If Steam is running, the destination * file names will be in %TEMP% and will be copied into * Steam's screenshot library for the running application * once SubmitScreenshot() is called. * If Steam is not running, the paths will be in the user's * documents folder under Documents\SteamVR\Screenshots. * Other VR applications can call this to initiate a * screenshot outside of user control. * The destination file names do not need an extension, * will be replaced with the correct one for the format * which is currently .png.
### SubmitScreenshot(System.UInt32,vr.EVRScreenshotType,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)
Submit the completed screenshot. If Steam is running * this will call into the Steam client and upload the * screenshot to the screenshots section of the library for * the running application. If Steam is not running, this * function will display a notification to the user that the * screenshot was taken. The paths should be full paths with * extensions. * File paths should be absolute including extensions. * screenshotHandle can be k_unScreenshotHandleInvalid if this * was a new shot taking by the app to be saved and not * initiated by a user (achievement earned or something)
### TakeStereoScreenshot(System.UInt32*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)
Tells the compositor to take an internal screenshot of * type VRScreenshotType_Stereo. It will take the current * submitted scene textures of the running application and * write them into the preview image and a side-by-side file * for the VR image. * This is similar to request screenshot, but doesn't ever * talk to the application, just takes the shot and submits.
### UpdateScreenshotProgress(System.UInt32,System.Single)
Call this if the application is taking the screen shot * will take more than a few ms processing. This will result * in an overlay being presented that shows a completion * bar.
### vr.IVRSpatialAnchors.CreateSpatialAnchorFromDescriptor(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.UInt32*)
Returns a handle for an spatial anchor described by "descriptor". On success, pHandle * will contain a handle valid for this session. Caller can wait for an event or occasionally * poll GetSpatialAnchorPose() to find the virtual coordinate associated with this anchor.
### vr.IVRSpatialAnchors.CreateSpatialAnchorFromPose(System.UInt32,vr.ETrackingUniverseOrigin,vr.SpatialAnchorPose_t*,System.UInt32*)
Returns a handle for an new spatial anchor at pPose. On success, pHandle * will contain a handle valid for this session. Caller can wait for an event or occasionally * poll GetSpatialAnchorDescriptor() to find the permanent descriptor for this pose. * The result of GetSpatialAnchorPose() may evolve from this initial position if the driver chooses * to update it. * The anchor will be associated with the driver that provides unDeviceIndex, and the driver may use that specific * device as a hint for how to best create the anchor. * The eOrigin must match whatever tracking origin you are working in (seated/standing/raw). * This should be called when the user is close to (and ideally looking at/interacting with) the target physical * location. At that moment, the driver will have the most information about how to recover that physical point * in the future, and the quality of the anchor (when the descriptor is re-used) will be highest. * The caller may decide to apply offsets from this initial pose, but is advised to stay relatively close to the * original pose location for highest fidelity.
### vr.IVRSpatialAnchors.GetSpatialAnchorDescriptor(System.UInt32,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,System.UInt32*)
Get the descriptor for a given handle. This will be empty for handles where the driver has not * yet built a descriptor. It will be the application-supplied descriptor for previously saved anchors * that the application is requesting poses for. If the driver has called UpdateSpatialAnchorDescriptor() * already in this session, it will be the descriptor provided by the driver. * Returns true if the descriptor fits into the buffer, else false. Buffer size should be at least * k_unMaxSpatialAnchorDescriptorSize.
### vr.IVRSpatialAnchors.GetSpatialAnchorPose(System.UInt32,vr.ETrackingUniverseOrigin,vr.SpatialAnchorPose_t*)
Get the pose for a given handle. This is intended to be cheap enough to call every frame (or fairly often) * so that the driver can refine this position when it has more information available.
### vr.IVRSystem.AcknowledgeQuit_Exiting
Call this to acknowledge to the system that VREvent_Quit has been received and that the process is exiting. * This extends the timeout until the process is killed.
### vr.IVRSystem.AcknowledgeQuit_UserPrompt
Call this to tell the system that the user is being prompted to save data. This * halts the timeout and dismisses the dashboard (if it was up). Applications should be sure to actually * prompt the user to save and then exit afterward, otherwise the user will be left in a confusing state.
### vr.IVRSystem.ApplyTransform(vr.TrackedDevicePose_t*,vr.TrackedDevicePose_t!System.Runtime.CompilerServices.IsConst*,vr.HmdMatrix34_t!System.Runtime.CompilerServices.IsConst*)
Convenience utility to apply the specified transform to the specified pose. * This properly transforms all pose components, including velocity and angular velocity
### vr.IVRSystem.ComputeDistortion(vr.EVREye,System.Single,System.Single,vr.DistortionCoordinates_t*)
Gets the result of the distortion function for the specified eye and input UVs. UVs go from 0,0 in * the upper left of that eye's viewport and 1,1 in the lower right of that eye's viewport. * Returns true for success. Otherwise, returns false, and distortion coordinates are not suitable.
### vr.IVRSystem.GetAppContainerFilePaths(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,System.UInt32)
Retrieves a null-terminated, semicolon-delimited list of UTF8 file paths that an application * must have read access to when running inside of an app container. Returns the number of bytes * needed to hold the list.
### vr.IVRSystem.GetArrayTrackedDeviceProperty(System.UInt32,vr.ETrackedDeviceProperty,System.UInt32,System.Void*,System.UInt32,vr.ETrackedPropertyError*)
Returns an array of one type of property. If the device index is not valid or the property is not a single value or an array of the specified type, * this function will return 0. Otherwise it returns the number of bytes necessary to hold the array of properties. If unBufferSize is * greater than the returned size and pBuffer is non-NULL, pBuffer is filled with the contents of array of properties.
### vr.IVRSystem.GetBoolTrackedDeviceProperty(System.UInt32,vr.ETrackedDeviceProperty,vr.ETrackedPropertyError*)
Returns a bool property. If the device index is not valid or the property is not a bool type this function will return false.
### vr.IVRSystem.GetButtonIdNameFromEnum(vr.EVRButtonId)
returns the name of an EVRButtonId enum value. This function is deprecated in favor of the new IVRInput system.
### vr.IVRSystem.GetControllerAxisTypeNameFromEnum(vr.EVRControllerAxisType)
returns the name of an EVRControllerAxisType enum value. This function is deprecated in favor of the new IVRInput system.
### vr.IVRSystem.GetControllerRoleForTrackedDeviceIndex(System.UInt32)
Returns the controller type associated with a device index. This function is deprecated in favor of the new IVRInput system.
### vr.IVRSystem.GetControllerState(System.UInt32,vr.VRControllerState001_t*,System.UInt32)
Fills the supplied struct with the current state of the controller. Returns false if the controller index * is invalid. This function is deprecated in favor of the new IVRInput system.
### vr.IVRSystem.GetControllerStateWithPose(vr.ETrackingUniverseOrigin,System.UInt32,vr.VRControllerState001_t*,System.UInt32,vr.TrackedDevicePose_t*)
fills the supplied struct with the current state of the controller and the provided pose with the pose of * the controller when the controller state was updated most recently. Use this form if you need a precise controller * pose as input to your application when the user presses or releases a button. This function is deprecated in favor of the new IVRInput system.
### vr.IVRSystem.GetD3D9AdapterIndex
[D3D9 Only] * Returns the adapter index that the user should pass into CreateDevice to set up D3D9 in such * a way that it can go full screen exclusive on the HMD. Returns -1 if there was an error.
### vr.IVRSystem.GetDeviceToAbsoluteTrackingPose(vr.ETrackingUniverseOrigin,System.Single,vr.TrackedDevicePose_t*,System.UInt32)
The pose that the tracker thinks that the HMD will be in at the specified number of seconds into the * future. Pass 0 to get the state at the instant the method is called. Most of the time the application should * calculate the time until the photons will be emitted from the display and pass that time into the method. * * This is roughly analogous to the inverse of the view matrix in most applications, though * many games will need to do some additional rotation or translation on top of the rotation * and translation provided by the head pose. * * For devices where bPoseIsValid is true the application can use the pose to position the device * in question. The provided array can be any size up to k_unMaxTrackedDeviceCount. * * Seated experiences should call this method with TrackingUniverseSeated and receive poses relative * to the seated zero pose. Standing experiences should call this method with TrackingUniverseStanding * and receive poses relative to the Chaperone Play Area. TrackingUniverseRawAndUncalibrated should * probably not be used unless the application is the Chaperone calibration tool itself, but will provide * poses relative to the hardware-specific coordinate system in the driver.
### vr.IVRSystem.GetDXGIOutputInfo(System.Int32*)
[D3D10/11 Only] * Returns the adapter index that the user should pass into EnumAdapters to create the device * and swap chain in DX10 and DX11. If an error occurs the index will be set to -1.
### vr.IVRSystem.GetEventTypeNameFromEnum(vr.EVREventType)
returns the name of an EVREvent enum value
### vr.IVRSystem.GetEyeToHeadTransform(vr.EVREye)
Returns the transform from eye space to the head space. Eye space is the per-eye flavor of head * space that provides stereo disparity. Instead of Model * View * Projection the sequence is Model * View * Eye^-1 * Projection. * Normally View and Eye^-1 will be multiplied together and treated as View in your application.
### vr.IVRSystem.GetFloatTrackedDeviceProperty(System.UInt32,vr.ETrackedDeviceProperty,vr.ETrackedPropertyError*)
Returns a float property. If the device index is not valid or the property is not a float type this function will return 0.
### vr.IVRSystem.GetHiddenAreaMesh(vr.EVREye,vr.EHiddenAreaMeshType)
Returns the hidden area mesh for the current HMD. The pixels covered by this mesh will never be seen by the user after the lens distortion is * applied based on visibility to the panels. If this HMD does not have a hidden area mesh, the vertex data and count will be NULL and 0 respectively. * This mesh is meant to be rendered into the stencil buffer (or into the depth buffer setting nearz) before rendering each eye's view. * This will improve performance by letting the GPU early-reject pixels the user will never see before running the pixel shader. * NOTE: Render this mesh with backface culling disabled since the winding order of the vertices can be different per-HMD or per-eye. * Setting the bInverse argument to true will produce the visible area mesh that is commonly used in place of full-screen quads. The visible area mesh covers all of the pixels the hidden area mesh does not cover. * Setting the bLineLoop argument will return a line loop of vertices in HiddenAreaMesh_t->pVertexData with HiddenAreaMesh_t->unTriangleCount set to the number of vertices.
### vr.IVRSystem.GetInt32TrackedDeviceProperty(System.UInt32,vr.ETrackedDeviceProperty,vr.ETrackedPropertyError*)
Returns an int property. If the device index is not valid or the property is not a int type this function will return 0.
### vr.IVRSystem.GetMatrix34TrackedDeviceProperty(System.UInt32,vr.ETrackedDeviceProperty,vr.ETrackedPropertyError*)
Returns a matrix property. If the device index is not valid or the property is not a matrix type, this function will return identity.
### vr.IVRSystem.GetProjectionMatrix(vr.EVREye,System.Single,System.Single)
The projection matrix for the specified eye
### vr.IVRSystem.GetProjectionRaw(vr.EVREye,System.Single*,System.Single*,System.Single*,System.Single*)
The components necessary to build your own projection matrix in case your * application is doing something fancy like infinite Z
### vr.IVRSystem.GetPropErrorNameFromEnum(vr.ETrackedPropertyError)
returns a string that corresponds with the specified property error. The string will be the name * of the error enum value for all valid error codes
### vr.IVRSystem.GetRawZeroPoseToStandingAbsoluteTrackingPose
Returns the transform from the tracking origin to the standing absolute tracking system. This allows * applications to convert from raw tracking space to the calibrated standing coordinate system.
### vr.IVRSystem.GetRecommendedRenderTargetSize(System.UInt32*,System.UInt32*)
Suggested size for the intermediate render target that the distortion pulls from.
### vr.IVRSystem.GetRuntimeVersion
Returns the current version of the SteamVR runtime. The returned string will remain valid until VR_Shutdown is called. * * NOTE: Is it not appropriate to use this version to test for the presence of any SteamVR feature. Only use this version * number for logging or showing to a user, and not to try to detect anything at runtime. When appropriate, feature-specific * presence information is provided by other APIs.
### vr.IVRSystem.GetSeatedZeroPoseToStandingAbsoluteTrackingPose
Returns the transform from the seated zero pose to the standing absolute tracking system. This allows * applications to represent the seated origin to used or transform object positions from one coordinate * system to the other. * * The seated origin may or may not be inside the Play Area or Collision Bounds returned by IVRChaperone. Its position * depends on what the user has set from the Dashboard settings and previous calls to ResetSeatedZeroPose.
### vr.IVRSystem.GetSortedTrackedDeviceIndicesOfClass(vr.ETrackedDeviceClass,System.UInt32*,System.UInt32,System.UInt32)
Get a sorted array of device indices of a given class of tracked devices (e.g. controllers). Devices are sorted right to left * relative to the specified tracked device (default: hmd -- pass in -1 for absolute tracking space). Returns the number of devices * in the list, or the size of the array needed if not large enough.
### vr.IVRSystem.GetStringTrackedDeviceProperty(System.UInt32,vr.ETrackedDeviceProperty,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,System.UInt32,vr.ETrackedPropertyError*)
Returns a string property. If the device index is not valid or the property is not a string type this function will * return 0. Otherwise it returns the length of the number of bytes necessary to hold this string including the trailing * null. Strings will always fit in buffers of k_unMaxPropertyStringSize characters.
### vr.IVRSystem.GetTimeSinceLastVsync(System.Single*,System.UInt64*)
Returns the number of elapsed seconds since the last recorded vsync event. This * will come from a vsync timer event in the timer if possible or from the application-reported * time if that is not available. If no vsync times are available the function will * return zero for vsync time and frame counter and return false from the method.
### vr.IVRSystem.GetTrackedDeviceActivityLevel(System.UInt32)
Returns the level of activity on the device.
### vr.IVRSystem.GetTrackedDeviceClass(System.UInt32)
Returns the device class of a tracked device. If there has not been a device connected in this slot * since the application started this function will return TrackedDevice_Invalid. For previous detected * devices the function will return the previously observed device class. * * To determine which devices exist on the system, just loop from 0 to k_unMaxTrackedDeviceCount and check * the device class. Every device with something other than TrackedDevice_Invalid is associated with an * actual tracked device.
### vr.IVRSystem.GetTrackedDeviceIndexForControllerRole(vr.ETrackedControllerRole)
Returns the device index associated with a specific role, for example the left hand or the right hand. This function is deprecated in favor of the new IVRInput system.
### vr.IVRSystem.GetUint64TrackedDeviceProperty(System.UInt32,vr.ETrackedDeviceProperty,vr.ETrackedPropertyError*)
Returns a uint64 property. If the device index is not valid or the property is not a uint64 type this function will return 0.
### vr.IVRSystem.IsDisplayOnDesktop
Use to determine if the headset display is part of the desktop (i.e. extended) or hidden (i.e. direct mode).
### vr.IVRSystem.IsInputAvailable
Returns true if this application is receiving input from the system. This would return false if * system-related functionality is consuming the input stream.
### vr.IVRSystem.IsSteamVRDrawingControllers
Returns true SteamVR is drawing controllers on top of the application. Applications should consider * not drawing anything attached to the user's hands in this case.
### vr.IVRSystem.IsTrackedDeviceConnected(System.UInt32)
Returns true if there is a device connected in this slot.
### vr.IVRSystem.PerformFirmwareUpdate(System.UInt32)
Performs the actual firmware update if applicable. * The following events will be sent, if VRFirmwareError_None was returned: VREvent_FirmwareUpdateStarted, VREvent_FirmwareUpdateFinished * Use the properties Prop_Firmware_UpdateAvailable_Bool, Prop_Firmware_ManualUpdate_Bool, and Prop_Firmware_ManualUpdateURL_String * to figure our whether a firmware update is available, and to figure out whether its a manual update * Prop_Firmware_ManualUpdateURL_String should point to an URL describing the manual update process
### vr.IVRSystem.PollNextEvent(vr.VREvent_t*,System.UInt32)
Returns true and fills the event with the next event on the queue if there is one. If there are no events * this method returns false. uncbVREvent should be the size in bytes of the VREvent_t struct
### vr.IVRSystem.PollNextEventWithPose(vr.ETrackingUniverseOrigin,vr.VREvent_t*,System.UInt32,vr.TrackedDevicePose_t*)
Returns true and fills the event with the next event on the queue if there is one. If there are no events * this method returns false. Fills in the pose of the associated tracked device in the provided pose struct. * This pose will always be older than the call to this function and should not be used to render the device. uncbVREvent should be the size in bytes of the VREvent_t struct
### vr.IVRSystem.ResetSeatedZeroPose
Sets the zero pose for the seated tracker coordinate system to the current position and yaw of the HMD. After * ResetSeatedZeroPose all GetDeviceToAbsoluteTrackingPose calls that pass TrackingUniverseSeated as the origin * will be relative to this new zero pose. The new zero coordinate system will not change the fact that the Y axis * is up in the real world, so the next pose returned from GetDeviceToAbsoluteTrackingPose after a call to * ResetSeatedZeroPose may not be exactly an identity matrix. * * NOTE: This function overrides the user's previously saved seated zero pose and should only be called as the result of a user action. * Users are also able to set their seated zero pose via the OpenVR Dashboard. *
### vr.IVRSystem.SetDisplayVisibility(System.Boolean)
Set the display visibility (true = extended, false = direct mode). Return value of true indicates that the change was successful.
### vr.IVRSystem.ShouldApplicationPause
Returns true if the user has put SteamVR into a mode that is distracting them from the application. * For applications where this is appropriate, the application should pause ongoing activity.
### vr.IVRSystem.ShouldApplicationReduceRenderingWork
Returns true if SteamVR is doing significant rendering work and the game should do what it can to reduce * its own workload. One common way to do this is to reduce the size of the render target provided for each eye.
### vr.IVRSystem.TriggerHapticPulse(System.UInt32,System.UInt32,System.UInt16)
Trigger a single haptic pulse on a controller. After this call the application may not trigger another haptic pulse on this controller * and axis combination for 5ms. This function is deprecated in favor of the new IVRInput system.
### vr.IVRTrackedCamera.AcquireVideoStreamingService(System.UInt32,System.UInt64*)
Acquiring streaming service permits video streaming for the caller. Releasing hints the system that video services do not need to be maintained for this client. * If the camera has not already been activated, a one time spin up may incur some auto exposure as well as initial streaming frame delays. * The camera should be considered a global resource accessible for shared consumption but not exclusive to any caller. * The camera may go inactive due to lack of active consumers or headset idleness.
### vr.IVRTrackedCamera.GetCameraErrorNameFromEnum(vr.EVRTrackedCameraError)
Returns a string for an error
### vr.IVRTrackedCamera.GetCameraFrameSize(System.UInt32,vr.EVRTrackedCameraFrameType,System.UInt32*,System.UInt32*,System.UInt32*)
Gets size of the image frame.
### vr.IVRTrackedCamera.GetVideoStreamFrameBuffer(System.UInt64,vr.EVRTrackedCameraFrameType,System.Void*,System.UInt32,vr.CameraVideoStreamFrameHeader_t*,System.UInt32)
Copies the image frame into a caller's provided buffer. The image data is currently provided as RGBA data, 4 bytes per pixel. * A caller can provide null for the framebuffer or frameheader if not desired. Requesting the frame header first, followed by the frame buffer allows * the caller to determine if the frame as advanced per the frame header sequence. * If there is no frame available yet, due to initial camera spinup or re-activation, the error will be VRTrackedCameraError_NoFrameAvailable. * Ideally a caller should be polling at ~16ms intervals
### vr.IVRTrackedCamera.GetVideoStreamTextureD3D11(System.UInt64,vr.EVRTrackedCameraFrameType,System.Void*,System.Void**,vr.CameraVideoStreamFrameHeader_t*,System.UInt32)
Access a shared D3D11 texture for the specified tracked camera stream. * The camera frame type VRTrackedCameraFrameType_Undistorted is not supported directly as a shared texture. It is an interior subregion of the shared texture VRTrackedCameraFrameType_MaximumUndistorted. * Instead, use GetVideoStreamTextureSize() with VRTrackedCameraFrameType_Undistorted to determine the proper interior subregion bounds along with GetVideoStreamTextureD3D11() with * VRTrackedCameraFrameType_MaximumUndistorted to provide the texture. The VRTrackedCameraFrameType_MaximumUndistorted will yield an image where the invalid regions are decoded * by the alpha channel having a zero component. The valid regions all have a non-zero alpha component. The subregion as described by VRTrackedCameraFrameType_Undistorted * guarantees a rectangle where all pixels are valid.
### vr.IVRTrackedCamera.GetVideoStreamTextureGL(System.UInt64,vr.EVRTrackedCameraFrameType,System.UInt32*,vr.CameraVideoStreamFrameHeader_t*,System.UInt32)
Access a shared GL texture for the specified tracked camera stream
### vr.IVRTrackedCamera.GetVideoStreamTextureSize(System.UInt32,vr.EVRTrackedCameraFrameType,vr.VRTextureBounds_t*,System.UInt32*,System.UInt32*)
Gets size of the image frame.
### vr.IVRTrackedCamera.HasCamera(System.UInt32,System.Boolean*)
For convenience, same as tracked property request Prop_HasCamera_Bool

## RenderModel_ComponentState_t
Describes state information about a render-model component, including transforms and other dynamic properties

## RenderModel_TextureMap_t
A texture map for use on a render model

## RenderModel_Vertex_t
A single vertex in a render model
### vr.SpatialAnchorHandle_t
A handle for a spatial anchor. This handle is only valid during the session it was created in. * Anchors that live beyond one session should be saved by their string descriptors.
### vr.TrackedDeviceIndex_t
Used to pass device IDs to API calls

## TrackedDevicePose_t
describes a single pose for a tracked object
### vr.VR_GetGenericInterface(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,vr.EVRInitError*)
Returns the interface of the specified version. This method must be called after VR_Init. The * pointer returned is valid until VR_Shutdown is called.
### vr.VR_GetInitToken
Returns a token that represents whether the VR interface handles need to be reloaded
### vr.VR_GetRuntimePath(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,System.UInt32,System.UInt32*)
Returns where the OpenVR runtime is installed.
### vr.VR_GetVRInitErrorAsEnglishDescription(vr.EVRInitError)
Returns an English string for an EVRInitError. Applications should call VR_GetVRInitErrorAsSymbol instead and * use that as a key to look up their own localized error message. This function may be called outside of VR_Init()/VR_Shutdown().
### vr.VR_GetVRInitErrorAsSymbol(vr.EVRInitError)
Returns the name of the enum value for an EVRInitError. This function may be called outside of VR_Init()/VR_Shutdown().
### vr.VR_Init(vr.EVRInitError*,vr.EVRApplicationType,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)
Finds the active installation of the VR API and initializes it. The provided path must be absolute * or relative to the current working directory. These are the local install versions of the equivalent * functions in steamvr.h and will work without a local Steam install. * * This path is to the "root" of the VR API install. That's the directory with * the "drivers" directory and a platform (i.e. "win32") directory in it, not the directory with the DLL itself. * * pStartupInfo is reserved for future use.
### vr.VR_Init(vr.EVRInitError*,vr.EVRApplicationType,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)
Finds the active installation of vrclient.dll and initializes it
### vr.VR_IsHmdPresent
Returns true if there is an HMD attached. This check is as lightweight as possible and * can be called outside of VR_Init/VR_Shutdown. It should be used when an application wants * to know if initializing VR is a possibility but isn't ready to take that step yet.
### vr.VR_IsInterfaceVersionValid(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)
Returns whether the interface of the specified version exists.
### vr.VR_IsRuntimeInstalled
Returns true if the OpenVR runtime is installed.
### vr.VR_Shutdown
unloads vrclient.dll. Any interface pointers from the interface are * invalid after this point
### vr.VR_Shutdown
unloads vrclient.dll. Any interface pointers from the interface are * invalid after this point
### vr.VRActiveActionSet_t.nPriority
The priority of this action set relative to other action sets. Any inputs * bound to a source (e.g. trackpad, joystick, trigger) will disable bindings in * other active action sets with a smaller priority.
### vr.VRActiveActionSet_t.ulActionSet
This is the handle of the action set to activate for this frame.
### vr.VRActiveActionSet_t.ulRestrictedToDevice
This is the handle of a device path that this action set should be active for. To * activate for all devices, set this to k_ulInvalidInputValueHandle.
### vr.VRActiveActionSet_t.ulSecondaryActionSet
The action set to activate for all devices other than ulRestrictedDevice. If * ulRestrictedToDevice is set to k_ulInvalidInputValueHandle, this parameter is * ignored.

## VRBoneTransform_t
Holds the transform for a single bone

## VRControllerAxis_t
contains information about one axis on the controller

## VRControllerState001_t
Holds all the state of a controller at one moment in time.

## VREvent_Controller_t
used for controller button events

## VREvent_Keyboard_t
Used for keyboard events *

## VREvent_Mouse_t
used for simulated mouse events in overlay space

## VREvent_Notification_t
notification related events. Details will still change at this point

## VREvent_Overlay_t
Used for a few events about overlays

## VREvent_Process_t
Used for events about processes

## VREvent_Reserved_t
Not actually used for any events

## VREvent_Scroll_t
used for simulated mouse wheel scroll

## VREvent_Status_t
Used for a few events about overlays

## VREvent_t
An event posted by the server to all running applications

## VREvent_TouchPadMove_t
when in mouse input mode you can receive data from the touchpad, these events are only sent if the users finger is on the touchpad (or just released from it). These events are sent to overlays with the VROverlayFlags_SendVRTouchpadEvents flag set. *

## VROverlayFlags
Overlay control settings
### vr.VROverlayHandle_t
used to refer to a single VR overlay

## VROverlayInputMethod
Types of input supported by VR Overlays

## VROverlayTransformType
Allows the caller to figure out which overlay transform getter to call.
### vr.VrProfilerEventHandle_t
Handle for vr profiler events

## VRSkeletalSummaryData_t
Contains summary information about the current skeletal pose
### flFingerCurl
The amount that each finger is 'curled' inwards towards the palm. In the case of the thumb, * this represents how much the thumb is wrapped around the fist. * 0 means straight, 1 means fully curled
### flFingerSplay
The amount that each pair of adjacent fingers are separated. * 0 means the digits are touching, 1 means they are fully separated.

## VRTextureBounds_t
Allows the application to control what part of the provided texture will be used in the * frame buffer.

## VRTextureWithPose_t
Allows specifying pose used to render provided scene texture (if different from value returned by WaitGetPoses).

## VRVulkanTextureData_t
Data required for passing Vulkan textures to IVRCompositor::Submit. * Be sure to call OpenVR_Shutdown before destroying these resources. * Please see https://github.com/ValveSoftware/openvr/wiki/Vulkan for Vulkan-specific documentation